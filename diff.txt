diff --git a/docs/Partie_01_gestion_utilisateurs.md b/docs/Partie_01_gestion_utilisateurs.md
deleted file mode 100644
index cd1e9ef..0000000
--- a/docs/Partie_01_gestion_utilisateurs.md
+++ /dev/null
@@ -1,656 +0,0 @@
-### **Gestion des utilisateurs :**
-   - **Inscription et connexion** : Permettre aux utilisateurs de créer un compte, se connecter et se déconnecter.
-   - **Gestion des profils** : Les utilisateurs peuvent mettre à jour leurs informations (nom, email, photo de profil, etc.).
-   - **Rôles et autorisations** : Implémenter différents rôles (ex. administrateur, utilisateur standard) avec des permissions spécifiques.
-
-
-Pour créer une API REST en .NET qui gère les utilisateurs et intègre Swagger pour la documentation, nous allons utiliser ASP.NET Core avec Entity Framework Core pour interagir avec une base de données MariaDB. Voici les étapes détaillées pour le projet `LibraryApi` du dépot `API-REST-DotNet-Library` :
-
-### Prérequis
-
-1. **.NET SDK** installé sur votre système (version 8.0 ou supérieure).
-2. **MariaDB** installé et en cours d'exécution.
-3. **Visual Studio Code** ou tout autre éditeur de code de votre choix.
-
-### Étape 1 : Créer le projet
-
-Ouvrez un terminal et exécutez les commandes suivantes pour créer le projet :
-
-```bash
-dotnet new webapi -n LibraryApi
-cd LibraryApi
-```
-
-### Étape 2 : Configurer le fichier .http
-Dans le fichier .http de votre projet déclarez la variable qui stocke l'adresse de l'API :
-
-```csharp
-// Déclaration d'une variable qui stocke l'adresse de l'API
-// Ici, la variable @LibraryApi_HostAddress est définie avec la valeur "http://localhost:5000".
-// Cela signifie que l'API est hébergée localement sur le port 5000.
-// Cette variable peut être réutilisée dans les requêtes suivantes pour éviter la répétition de l'URL.
-
-@LibraryApi_HostAddress = http://localhost:5000
-
-```
-
-
-### Étape 3 : Ajouter les dépendances
-
-Ajoutez les packages nécessaires pour Entity Framework Core et Swagger. Exécutez ces commandes dans le terminal :
-
-```bash
-
-dotnet add package Microsoft.AspNetCore.Authentication.JwtBearer
-dotnet add package Microsoft.AspNetCore.Identity.EntityFrameworkCore
-dotnet add package Microsoft.AspNetCore.OpenApi
-dotnet add package Microsoft.EntityFrameworkCore
-dotnet add package Microsoft.EntityFrameworkCore.Tools
-dotnet add package Pomelo.EntityFrameworkCore.MySql
-dotnet add package Swashbuckle.AspNetCore
-
-```
-
-### Étape 4 : Configurer la base de données
-
-Créez un fichier de configuration pour la connexion à la base de données. Dans `appsettings.json`, ajoutez la chaîne de connexion suivante :
-
-```json
-{
-  "_comment_ConnectionStrings": "Cette section contient la chaîne de connexion à MariaDB.",
-  "ConnectionStrings": {
-    "MariaDBConnection": "server=localhost;port=3306;database=librarydb;user=myuser;password=mypassword"
-  },
-
-  "_comment_Jwt": "Cette section contient les informations de configuration pour les tokens JWT.",
-  "Jwt": {
-    "Key": "YourSuperSecretKeyWithAtLeast16Chars",
-    "Issuer": "LibraryApi",
-    "Audience": "LibraryApiUsers",
-    "_comment_Key": "Assurez-vous que la clé JWT est suffisamment complexe et secrète.",
-    "_comment_Issuer_Audience": "L'Issuer et l'Audience sont utilisés pour valider le token."
-  },
-
-  "_comment_Logging": "Cette section configure le logging pour l'application.",
-  "Logging": {
-    "LogLevel": {
-      "Default": "Information",
-      "Microsoft.AspNetCore": "Warning"
-    }
-  },
-
-  "_comment_AllowedHosts": "Liste des hôtes autorisés à accéder à l'application.",
-  "AllowedHosts": "*",
-
-  "_comment_CORS": "Configurer les règles CORS pour permettre ou restreindre l'accès à l'API.",
-  "Cors": {
-    "AllowedOrigins": [ "http://localhost:3000", "http://example.com" ],
-    "AllowCredentials": true
-  },
-
-
-
-  "_comment_AppSettings": "Paramètres spécifiques à l'application.",
-  "AppSettings": {
-    "FeatureXEnabled": true,
-    "MaxItemsToShow": 100
-  }
-}
-```
-
-Assurez-vous de remplacer `myuser` par le nom de votre utilisateur MariaDB.
-Assurez-vous de remplacer `mypassword` par le mot de passe de votre utilisateur MariaDB.
-
-### Étape 5. Configuration de MariaDB dans Program.cs
-On configure MariaDB avec EF Core dans le fichier Program.cs pour connecter l'API à la base de données :
-
-```csharp
-// Importation des bibliothèques nécessaires pour utiliser Entity Framework Core avec un fournisseur de base de données
-using Microsoft.EntityFrameworkCore;
-// Importation des bibliothèques nécessaires pour configurer l'authentification via JWT (JSON Web Token) dans une application ASP.NET Core
-using Microsoft.AspNetCore.Authentication.JwtBearer;
-// Importation des bibliothèques pour gérer la validation des jetons JWT, notamment pour les configurations de sécurité
-using Microsoft.IdentityModel.Tokens;
-// Importation de System.Text pour encoder les clés de sécurité sous forme de chaînes de caractères (UTF8)
-using System.Text;
-// Importation de la gestion des identités (utilisateurs, rôles) dans ASP.NET Core via Identity
-using Microsoft.AspNetCore.Identity;
-// Importation des bibliothèques nécessaires pour configurer Swagger, un outil de documentation d'API
-using Microsoft.OpenApi.Models;
-
-// Initialisation du constructeur d'application Web avec les paramètres passés (ici, les arguments d'exécution)
-var builder = WebApplication.CreateBuilder(args);
-
-// Configuration de la chaîne de connexion à MariaDB
-// Ceci ajoute le service de contexte de base de données à l'application, en précisant que nous utilisons MariaDB comme SGBD
-// "ApplicationDbContext" est une classe qui représente le contexte de la base de données dans Entity Framework
-builder.Services.AddDbContext<ApplicationDbContext>(options =>
-    // Configuration pour utiliser MySQL (MariaDB) avec les informations de connexion définies dans appsettings.json sous "MariaDBConnection"
-    options.UseMySql(builder.Configuration.GetConnectionString("MariaDBConnection"),
-    // Définition de la version spécifique de MySQL/MariaDB utilisée (ici, la version 10.6.4)
-    new MySqlServerVersion(new Version(10, 6, 4)))
-);
-
-// Ajout du système d'authentification avec Identity
-// "Identity" est un système intégré à ASP.NET Core pour la gestion des utilisateurs et des rôles
-builder.Services.AddIdentity<ApplicationUser, IdentityRole>()
-    // Stocke les informations des utilisateurs et des rôles dans la base de données via Entity Framework
-    .AddEntityFrameworkStores<ApplicationDbContext>()
-    // Ajoute des fournisseurs de jetons (utilisés par exemple pour la gestion des tokens de réinitialisation de mot de passe, de vérification des emails, etc.)
-    .AddDefaultTokenProviders();
-
-// Configuration de l'authentification via JWT (JSON Web Token)
-// Ici, on configure l'application pour qu'elle utilise JWT comme méthode d'authentification
-builder.Services.AddAuthentication(options =>
-{
-    // Définit le schéma d'authentification par défaut pour cette application en tant que JWT
-    options.DefaultAuthenticateScheme = JwtBearerDefaults.AuthenticationScheme;
-    // Définit le schéma d'authentification à utiliser en cas de défi d'authentification (par exemple, quand un utilisateur non authentifié tente d'accéder à une ressource protégée)
-    options.DefaultChallengeScheme = JwtBearerDefaults.AuthenticationScheme;
-})
-// Configuration spécifique du traitement des jetons JWT pour leur validation
-.AddJwtBearer(options =>
-{
-    options.TokenValidationParameters = new TokenValidationParameters
-    {
-        // Exige que l'émetteur du jeton soit validé (pour s'assurer que le jeton provient d'une source de confiance)
-        ValidateIssuer = true,
-        // Exige que l'audience du jeton soit validée (pour s'assurer que le jeton est destiné à cette application)
-        ValidateAudience = true,
-        // Exige que la durée de vie du jeton soit validée (pour éviter d'accepter des jetons expirés)
-        ValidateLifetime = true,
-        // Exige que la clé de signature du jeton soit validée (pour s'assurer que le jeton n'a pas été altéré)
-        ValidateIssuerSigningKey = true,
-        // Spécifie l'émetteur valide du jeton (généralement l'URL de l'API ou du serveur d'authentification)
-        ValidIssuer = builder.Configuration["Jwt:Issuer"],
-        // Spécifie l'audience valide du jeton (qui doit être le consommateur du jeton, par exemple une application cliente)
-        ValidAudience = builder.Configuration["Jwt:Audience"],
-        // Clé utilisée pour signer le jeton, encodée en UTF-8
-        IssuerSigningKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(builder.Configuration["Jwt:Key"]))
-    };
-});
-
-// Ajout des services de contrôleurs API à l'application
-// Cela permet à l'application de reconnaître et gérer les requêtes HTTP dirigées vers les points de terminaison définis dans les contrôleurs
-builder.Services.AddControllers();
-
-// Ajout de Swagger pour générer la documentation de l'API
-// Swagger génère automatiquement une interface graphique interactive et un fichier JSON décrivant les routes et points de terminaison de l'API
-builder.Services.AddSwaggerGen(c =>
-{
-    // Configuration de la version de Swagger, avec un titre et une version pour l'API
-    c.SwaggerDoc("v1", new OpenApiInfo { Title = "LibraryApi", Version = "v1" });
-
-    // Configuration de Swagger pour inclure l'authentification JWT
-    c.AddSecurityDefinition("Bearer", new OpenApiSecurityScheme
-    {
-        // Description de la manière d'utiliser le token JWT (ici, en tant que valeur de l'en-tête Authorization)
-        Description = "JWT Authorization header using the Bearer scheme. Example: \"Authorization: Bearer {token}\"",
-        Name = "Authorization",  // Nom du champ dans l'en-tête HTTP qui contiendra le token JWT
-        In = ParameterLocation.Header,  // Le token JWT sera fourni dans l'en-tête de la requête HTTP
-        Type = SecuritySchemeType.ApiKey,  // Définit que c'est un schéma de sécurité basé sur un token (API key)
-        Scheme = "Bearer"  // Spécifie que nous utilisons le schéma "Bearer" pour la transmission du token
-    });
-
-    // Définition de la sécurité requise pour les points de terminaison dans l'API (requiert un token JWT pour certains endpoints)
-    c.AddSecurityRequirement(new OpenApiSecurityRequirement()
-    {
-        {
-            new OpenApiSecurityScheme
-            {
-                Reference = new OpenApiReference
-                {
-                    Type = ReferenceType.SecurityScheme,
-                    Id = "Bearer"  // Se réfère au schéma de sécurité défini précédemment
-                },
-                Scheme = "oauth2",  // Précise que le schéma est basé sur OAuth2 pour l'authentification
-                Name = "Bearer",
-                In = ParameterLocation.Header,  // Précise que le token sera transmis dans l'en-tête
-            },
-            new List<string>()  // Aucune autorisation spécifique requise (vide)
-        }
-    });
-});
-
-// Construction de l'application avec tous les services configurés précédemment
-var app = builder.Build();
-
-app.UseStaticFiles();  // Permet de servir les fichiers statiques depuis wwwroot
-
-// Configuration pour n'activer Swagger que dans l'environnement de développement (en évitant d'exposer la documentation en production)
-if (app.Environment.IsDevelopment())
-{
-    app.UseSwagger();  // Active Swagger pour générer la documentation API
-    app.UseSwaggerUI(c =>
-    {
-        // Définition de l'URL où accéder à la documentation de l'API (fichier JSON Swagger)
-        c.SwaggerEndpoint("/swagger/v1/swagger.json", "LibraryApi v1");
-    });
-}
-
-// Active l'authentification dans le pipeline des requêtes HTTP
-app.UseAuthentication();
-
-// Active l'autorisation (vérification des droits d'accès aux ressources) dans le pipeline des requêtes HTTP
-app.UseAuthorization();
-
-// Mappage des contrôleurs API pour gérer les requêtes HTTP et les rediriger vers les contrôleurs appropriés
-app.MapControllers();
-
-// Lancement de l'application (écoute des requêtes entrantes)
-app.Run();
-
-```
-
-### Étape 6 : Créer la base de données avec Entity Framework
-Créons les classes pour le modèle utilisateur (ApplicationUser) et la base de données (ApplicationDbContext).
-
-#### 6.1. Modèle ApplicationUser.cs
-Créez un fichier Models/ApplicationUser.cs :
-
-```csharp
-// Importation du namespace pour ASP.NET Core Identity.
-// Identity permet de gérer les utilisateurs, leurs rôles, la connexion, les claims, etc.
-using Microsoft.AspNetCore.Identity;
-
-// Déclaration de la classe ApplicationUser, qui étend (hérite de) IdentityUser.
-// IdentityUser est la classe de base fournie par ASP.NET Core Identity pour gérer les utilisateurs.
-// Cette classe inclut des propriétés de base comme UserName, Email, PasswordHash, etc.
-// ApplicationUser permet d'ajouter des propriétés supplémentaires spécifiques à l'application.
-public class ApplicationUser : IdentityUser
-{
-    // Propriété FullName : permet de stocker le nom complet de l'utilisateur.
-    // Le point d'interrogation (?) indique que cette propriété est nullable, c'est-à-dire
-    // qu'elle peut ne pas avoir de valeur (null) si l'utilisateur ne fournit pas de nom complet.
-    public string? FullName { get; set; }
-    // Propriété Description : permet de stocker une description personnelle ou une biographie
-    // de l'utilisateur. Elle est également nullable.
-    public string? Description { get; set; }
-    // Propriété ProfilePicture : permet de stocker l'URL d'une image de profil associée à l'utilisateur.
-    // Cette propriété est aussi nullable, donc l'utilisateur peut ne pas avoir d'image de profil.
-     public string? ProfilePicture { get; set; }
-    // Ajout de cette propriété pour gérer l'upload de l'image de profil
-     //public IFormFile? ProfilePicture { get; set; }
-
-
-}
-```
-
-#### 6.2. Créer la classe ApplicationDbContext.cs
-Créez un fichier Data/ApplicationDbContext.cs :
-
-```csharp
-// Importation du namespace nécessaire pour utiliser Identity avec Entity Framework Core.
-// Identity permet la gestion des utilisateurs, rôles, connexions, etc.
-using Microsoft.AspNetCore.Identity.EntityFrameworkCore;
-// Importation du namespace pour Entity Framework Core qui permet l'accès aux bases de données.
-using Microsoft.EntityFrameworkCore;
-
-// Déclaration de la classe ApplicationDbContext qui hérite de IdentityDbContext.
-// IdentityDbContext est une classe spéciale fournie par ASP.NET Core Identity qui
-// étend DbContext (le contexte de base de données d'Entity Framework) et inclut
-// toutes les entités nécessaires pour la gestion des utilisateurs, rôles, et autres
-// fonctionnalités d'ASP.NET Core Identity. Nous utilisons ApplicationUser comme
-// modèle utilisateur personnalisé.
-public class ApplicationDbContext : IdentityDbContext<ApplicationUser>
-{
-    // Constructeur de la classe ApplicationDbContext qui appelle le constructeur de la classe parente (base).
-    // Il prend en paramètre un DbContextOptions, qui contient les informations nécessaires pour
-    // configurer le contexte, comme la chaîne de connexion à la base de données.
-    public ApplicationDbContext(DbContextOptions<ApplicationDbContext> options) : base(options)
-    {
-        // Le corps du constructeur est vide ici, car toute la logique de configuration
-        // est gérée par la classe de base (IdentityDbContext) et les options passées.
-    }
-}
-```
-
-### Étape 7 : Gestion des utilisateurs : Inscription, Connexion et Rôles
-
-#### 7.1. Créer le contrôleur AuthController.cs
-Créez un fichier Controllers/AuthController.cs pour gérer l’inscription, la connexion et la gestion des rôles.
-
-```csharp
-using Microsoft.AspNetCore.Mvc;  // Pour gérer les contrôleurs et les actions d'API
-using Microsoft.AspNetCore.Identity;  // Pour utiliser Identity (gestion des utilisateurs, rôles, etc.)
-using Microsoft.AspNetCore.Authorization;  // Pour gérer les attributs d'autorisation
-using System.IdentityModel.Tokens.Jwt;  // Pour manipuler les tokens JWT
-using System.Security.Claims;  // Pour créer et gérer les claims dans les tokens JWT
-using Microsoft.IdentityModel.Tokens;  // Pour gérer la validation et la signature des tokens JWT
-using System.Text;  // Pour encoder les clés de sécurité
-using Microsoft.AspNetCore.Http;  // Pour utiliser IFormFile
-using System.IO;  // Pour utiliser Path et FileStream
-
-// Attributs de route et API pour lier ce contrôleur à une route "api/Auth"
-[Route("api/[controller]")]
-[ApiController]
-public class AuthController : ControllerBase
-{
-    // Déclaration des services utilisés dans le contrôleur
-    private readonly UserManager<ApplicationUser> _userManager;
-    private readonly SignInManager<ApplicationUser> _signInManager;
-    private readonly RoleManager<IdentityRole> _roleManager;
-    private readonly IConfiguration _configuration;
-
-    // Constructeur pour injecter les dépendances (services)
-    public AuthController(UserManager<ApplicationUser> userManager, SignInManager<ApplicationUser> signInManager,
-        RoleManager<IdentityRole> roleManager, IConfiguration configuration)
-    {
-        _userManager = userManager;
-        _signInManager = signInManager;
-        _roleManager = roleManager;
-        _configuration = configuration;
-    }
-
-// Action pour mettre à jour le profil de l'utilisateur connecté
-[HttpPut("update-profile")]
-[Authorize]
-public async Task<IActionResult> UpdateProfile([FromForm] UpdateProfileModel model)
-{
-    var user = await _userManager.GetUserAsync(User);
-    if (user == null) return NotFound();
-
-    // Mise à jour du nom et de la description
-    if (!string.IsNullOrEmpty(model.FullName))
-    {
-        user.FullName = model.FullName;
-    }
-
-    if (!string.IsNullOrEmpty(model.Description))
-    {
-        user.Description = model.Description;
-    }
-
-    // Gestion du fichier d'image de profil
-    if (model.ProfilePicture != null && model.ProfilePicture.Length > 0)
-    {
-        // Définir le chemin où stocker l'image (wwwroot/images/profiles/)
-        var imagePath = Path.Combine("wwwroot/images/profiles", $"{user.Id}_{model.ProfilePicture.FileName}");
-
-        // Sauvegarder l'image sur le serveur
-        using (var stream = new FileStream(imagePath, FileMode.Create))
-        {
-            await model.ProfilePicture.CopyToAsync(stream);
-        }
-
-        // Stocker le chemin relatif dans la base de données
-        user.ProfilePicture = $"/images/profiles/{user.Id}_{model.ProfilePicture.FileName}";
-    }
-
-    // Sauvegarder les modifications dans la base de données
-    var result = await _userManager.UpdateAsync(user);
-    if (result.Succeeded)
-    {
-        return Ok(new { Message = "Profile updated successfully!", ProfilePictureUrl = user.ProfilePicture });
-    }
-
-    return BadRequest(result.Errors);
-}
-
-
-    // Action pour enregistrer un nouvel utilisateur
-    [HttpPost("register")]
-    public async Task<IActionResult> Register([FromBody] RegisterModel model)
-    {
-        // Création d'un nouvel utilisateur basé sur les données fournies
-        var user = new ApplicationUser
-        {
-            UserName = model.Email,
-            Email = model.Email,
-            FullName = model.FullName,
-            Description = model.Description
-        };
-
-        // Création de l'utilisateur avec le mot de passe fourni
-        var result = await _userManager.CreateAsync(user, model.Password);
-        if (result.Succeeded)
-        {
-            // Si le rôle "User" n'existe pas, on le crée
-            if (!await _roleManager.RoleExistsAsync("User"))
-                await _roleManager.CreateAsync(new IdentityRole("User"));
-
-            // On assigne le rôle "User" au nouvel utilisateur
-            await _userManager.AddToRoleAsync(user, "User");
-
-            // Retourner un message de succès
-            return Ok(new { Message = "User registered successfully!" });
-        }
-
-        // En cas d'échec de création, retourner les erreurs
-        return BadRequest(result.Errors);
-    }
-
-    // Action pour connecter un utilisateur et générer un token JWT
-    [HttpPost("login")]
-    public async Task<IActionResult> Login([FromBody] LoginModel model)
-    {
-        // Tentative de connexion avec le mot de passe fourni
-        var result = await _signInManager.PasswordSignInAsync(model.Email, model.Password, false, false);
-
-        if (result.Succeeded)
-        {
-            // Si la connexion réussit, récupérer l'utilisateur et ses rôles
-            var user = await _userManager.FindByEmailAsync(model.Email);
-            var roles = await _userManager.GetRolesAsync(user);
-
-            // Générer un token JWT pour l'utilisateur
-            var token = GenerateJwtToken(user, roles);
-            return Ok(new { Token = token });
-        }
-
-        // Si la connexion échoue, retourner une erreur Unauthorized (401)
-        return Unauthorized();
-    }
-
-    // Action pour déconnecter un utilisateur (supprimer sa session)
-    [HttpPost("logout")]
-    [Authorize]  // Nécessite que l'utilisateur soit authentifié
-    public async Task<IActionResult> Logout()
-    {
-        // Déconnexion de l'utilisateur
-        await _signInManager.SignOutAsync();
-        return Ok(new { Message = "Logged out successfully!" });
-    }
-
-    // Méthode privée pour générer un token JWT pour un utilisateur
-    private string GenerateJwtToken(ApplicationUser user, IList<string> roles)
-    {
-        // Création des claims pour le token (Id, Email, Username, et rôles)
-        var claims = new List<Claim>
-        {
-            new Claim(JwtRegisteredClaimNames.Sub, user.Id),
-            new Claim(JwtRegisteredClaimNames.Email, user.Email),
-            new Claim(ClaimTypes.Name, user.UserName)
-        };
-
-        // Ajout des rôles en tant que claims
-        claims.AddRange(roles.Select(role => new Claim(ClaimTypes.Role, role)));
-
-        // Récupération de la clé secrète pour signer le token
-        var key = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(_configuration["Jwt:Key"]));
-        var creds = new SigningCredentials(key, SecurityAlgorithms.HmacSha256);
-        var token = new JwtSecurityToken(
-            issuer: _configuration["Jwt:Issuer"],
-            audience: _configuration["Jwt:Audience"],
-            claims: claims,
-            expires: DateTime.Now.AddHours(3),
-            signingCredentials: creds);
-
-        // Création du token avec des informations comme l'émetteur, l'audience, et la durée d'expiration
-        return new JwtSecurityTokenHandler().WriteToken(token);
-    }
-}
-```
-
-#### 7.2. Modèles pour l'inscription et la connexion
-Créez un fichier Models/AuthModels.cs :
-
-```csharp
-// Classe utilisée pour le modèle de données lors de l'enregistrement d'un utilisateur.
-// Cette classe sera utilisée pour recevoir les informations envoyées par le client (comme un formulaire de registration) lors de la création d'un nouveau compte utilisateur.
-
-public class RegisterModel
-{
-    // Propriété FullName : représente le nom complet de l'utilisateur qui sera enregistré.
-    // C'est un champ requis pour l'enregistrement.
-    public string FullName { get; set; }
-
-    // Propriété Email : représente l'email de l'utilisateur qui sera utilisé comme identifiant unique pour la connexion.
-    // C'est un champ requis pour l'enregistrement.
-    public string Email { get; set; }
-
-    // Propriété Description : permet à l'utilisateur de fournir une description personnelle ou une biographie lors de l'enregistrement.
-    // C'est un champ optionnel pour l'enregistrement.
-    public string Description { get; set; }
-
-    // Propriété Password : représente le mot de passe de l'utilisateur. Ce mot de passe sera hashé avant d'être stocké dans la base de données.
-    // C'est un champ requis pour l'enregistrement.
-    public string Password { get; set; }
-}
-
-// Classe utilisée pour le modèle de données lors de la connexion d'un utilisateur.
-// Cette classe sera utilisée pour recevoir les informations envoyées par le client (comme un formulaire de login) lors de la tentative de connexion d'un utilisateur.
-
-public class LoginModel
-{
-    // Propriété Email : représente l'email ou l'identifiant de l'utilisateur.
-    // C'est un champ requis pour la connexion.
-    public string Email { get; set; }
-
-    // Propriété Password : représente le mot de passe saisi par l'utilisateur pour s'authentifier.
-    // C'est un champ requis pour la connexion.
-    public string Password { get; set; }
-}
-```
-
-#### 7.3. Gérer les rôles (administrateur)
-Dans Program.cs, vous pouvez ajouter un utilisateur administrateur au démarrage si celui-ci n'existe pas :
-```csharp
-using (var scope = app.Services.CreateScope())
-{
-    var roleManager = scope.ServiceProvider.GetRequiredService<RoleManager<IdentityRole>>();
-    var userManager = scope.ServiceProvider.GetRequiredService<UserManager<ApplicationUser>>();
-
-    if (!await roleManager.RoleExistsAsync("Admin"))
-        await roleManager.CreateAsync(new IdentityRole("Admin"));
-
-    var adminUser = await userManager.FindByEmailAsync("admin@library.com");
-    if (adminUser == null)
-    {
-        var user = new ApplicationUser
-        {
-            UserName = "admin@library.com",
-            Email = "admin@library.com",
-            FullName = "Admin",
-            Description = "Administrator Account"
-        };
-
-        await userManager.CreateAsync(user, "AdminPass123!");
-        await userManager.AddToRoleAsync(user, "Admin");
-    }
-}
-```
-
-### Étape 8 : Mise à jour du profil utilisateur
-Dans le même contrôleur AuthController.cs, ajoute une méthode pour mettre à jour les informations de l'utilisateur.
-
-```csharp
- // Action pour mettre à jour le profil de l'utilisateur connecté
-[HttpPut("update-profile")]
-[Authorize]
-public async Task<IActionResult> UpdateProfile([FromForm] UpdateProfileModel model)
-{
-    var user = await _userManager.GetUserAsync(User);
-    if (user == null) return NotFound();
-
-    // Mise à jour du nom et de la description
-    if (!string.IsNullOrEmpty(model.FullName))
-    {
-        user.FullName = model.FullName;
-    }
-
-    if (!string.IsNullOrEmpty(model.Description))
-    {
-        user.Description = model.Description;
-    }
-
-    // Gestion du fichier d'image de profil
-    if (model.ProfilePicture != null && model.ProfilePicture.Length > 0)
-    {
-        // Définir le chemin où stocker l'image (wwwroot/images/profiles/)
-        var imagePath = Path.Combine("wwwroot/images/profiles", $"{user.Id}_{model.ProfilePicture.FileName}");
-
-        // Sauvegarder l'image sur le serveur
-        using (var stream = new FileStream(imagePath, FileMode.Create))
-        {
-            await model.ProfilePicture.CopyToAsync(stream);
-        }
-
-        // Stocker le chemin relatif dans la base de données
-        user.ProfilePicture = $"/images/profiles/{user.Id}_{model.ProfilePicture.FileName}";
-    }
-
-    // Sauvegarder les modifications dans la base de données
-    var result = await _userManager.UpdateAsync(user);
-    if (result.Succeeded)
-    {
-        return Ok(new { Message = "Profile updated successfully!", ProfilePictureUrl = user.ProfilePicture });
-    }
-
-    return BadRequest(result.Errors);
-}
-
-```
-
-Modèle pour la mise à jour du profil à ajouter dans Models:
-
-
-```csharp
-using Microsoft.AspNetCore.Http;  // Ajouter cette directive
-
-// Classe utilisée pour le modèle de données lors de la mise à jour du profil utilisateur.
-// Cette classe est utilisée pour recevoir les informations que l'utilisateur souhaite modifier dans son profil.
-// Les champs sont optionnels (nullable), donc l'utilisateur peut choisir de ne mettre à jour que certains champs.
-
-public class UpdateProfileModel
-{
-    // Propriété FullName : représente le nom complet que l'utilisateur souhaite définir ou modifier.
-    // Le point d'interrogation (?) indique que cette propriété est nullable, ce qui signifie que l'utilisateur peut ne pas fournir cette information.
-    public string? FullName { get; set; }
-
-    // Propriété Description : permet à l'utilisateur de mettre à jour ou ajouter une description personnelle ou une biographie.
-    // Elle est également nullable, donc l'utilisateur peut ne pas la remplir.
-    public string? Description { get; set; }
-
-    // Propriété ProfilePicture : représente l'URL de l'image de profil que l'utilisateur souhaite ajouter ou mettre à jour.
-    // Comme les autres, elle est nullable, ce qui signifie que l'utilisateur peut ne pas changer l'image de profil.
-    public IFormFile? ProfilePicture { get; set; }
-}
-
-```
-
-### Étape 9. Exécuter les migrations et la base de données
-Finalement, exécute dans le terminal les commandes suivantes pour créer et mettre à jour la base de données :
-
-```csharp
-dotnet ef migrations add InitialCreate
-dotnet ef database update
-```
-
-### Étape 10 : Documentation Swagger
-Swagger est déjà intégré dans le fichier Program.cs. Tu peux accéder à la documentation API en accédant à l'URL /swagger une fois le projet exécuté.
-
-Maintenant que tout est configuré, vous pouvez exécuter l'application :
-
-```bash
-dotnet run
-```
-
-Accédez à `http://localhost:5000/swagger` pour voir la documentation Swagger de votre API.
-
-### Conclusion
-Vous avez maintenant une API REST de base pour gérer les utilisateurs, avec des fonctionnalités d'inscription, de connexion, de déconnexion, de mise à jour des profils et de gestion des rôles. Vous pouvez étendre cette API en ajoutant des fonctionnalités supplémentaires pour gérer les livres et les magazines.
-
-N'oubliez pas de tester l'API et de vous assurer que les autorisations fonctionnent correctement, notamment l'accès à certaines routes en fonction des rôles.
-
-
diff --git a/docs/Partie_02_gestion_livres.md b/docs/Partie_02_gestion_livres.md
deleted file mode 100644
index d37a052..0000000
--- a/docs/Partie_02_gestion_livres.md
+++ /dev/null
@@ -1,447 +0,0 @@
-
-### **Gestion des livres et magazines :**
-   - **Ajout de contenu** : Permettre aux utilisateurs d'ajouter des livres ou des magazines (titre, auteur, description, catégorie, fichier PDF ou EPUB, etc.).
-   - **Consultation du contenu** : Les utilisateurs peuvent rechercher et consulter les détails des livres ou magazines disponibles.
-   - **Téléchargement** : Option de télécharger le fichier du livre ou du magazine en différents formats (PDF, EPUB).
-   - **Catégories et tags** : Organisation des contenus par catégories ou tags pour faciliter la recherche.
-
-
-
-
-Pour implémenter la **partie 2 - Gestion des livres et magazines** du projet d'API REST .NET, nous allons ajouter les fonctionnalités suivantes :
-
-1. **Création des tables `Author` et `Category` pour stocker les auteurs et les catégories séparément.**
-2. **Ajout des relations entre `BookMagazine` et `Author` ainsi qu'entre `BookMagazine` et `Category` (les deux via des clés étrangères).**
-3. **Mise à jour du contrôleur pour vérifier si un auteur ou une catégorie existe déjà avant d'ajouter un nouveau livre ou magazine, et créer les entrées si nécessaire.**
-
-### 1. **Modèles `Author` et `Category`**
-Nous allons créer des modèles pour représenter l'auteur et la catégorie du livre.
-
-#### Modèle `Author.cs` :
-```csharp
-using System.Collections.Generic;
-using System.ComponentModel.DataAnnotations;
-
-public class Author
-{
-    [Key]
-    public int Id { get; set; }
-
-    [Required]
-    public string Name { get; set; }
-
-    // Relation avec BookMagazine (un auteur peut avoir plusieurs livres/magazines)
-    public ICollection<BookMagazine> BooksMagazines { get; set; }
-}
-```
-
-#### Modèle `Category.cs` :
-```csharp
-using System.Collections.Generic;
-using System.ComponentModel.DataAnnotations;
-
-public class Category
-{
-    [Key]
-    public int Id { get; set; }
-
-    [Required]
-    public string Name { get; set; }
-
-    // Relation avec BookMagazine (une catégorie peut avoir plusieurs livres/magazines)
-    public ICollection<BookMagazine> BooksMagazines { get; set; }
-}
-```
-
-
-### 2. **Modèles pour les livres et magazines :**
-Nous allons créer des modèles pour représenter les livres et magazines dans la base de données, avec des informations comme le titre, l'auteur, la description, la catégorie, le fichier (PDF/EPUB), etc.
-
-#### Création du modèle `BookMagazine.cs` :
-```csharp
-using System.ComponentModel.DataAnnotations;
-using System.ComponentModel.DataAnnotations.Schema;
-
-public class BookMagazine
-{
-    [Key]
-    public int Id { get; set; }
-
-    [Required]
-    public string Title { get; set; }
-
-    [Required]
-    public int AuthorId { get; set; }  // Foreign key vers l'auteur
-    [ForeignKey("AuthorId")]
-    public Author Author { get; set; }
-
-    public string Description { get; set; }
-
-    [Required]
-    public int CategoryId { get; set; }  // Foreign key vers la catégorie
-    [ForeignKey("CategoryId")]
-    public Category Category { get; set; }
-
-    public string Tags { get; set; }
-
-    [Required]
-    public string FilePath { get; set; }
-
-    public string CoverImagePath { get; set; }
-
-    public DateTime UploadDate { get; set; } = DateTime.Now;
-}
-
-```
-
-### 3. **Mise à jour du contexte de base de données :**
-
-Ensuite, nous devons enregistrer ce nouveau modèle dans `ApplicationDbContext.cs`.
-
-```csharp
-// Importation du namespace nécessaire pour utiliser Identity avec Entity Framework Core.
-// Identity permet la gestion des utilisateurs, rôles, connexions, etc.
-using Microsoft.AspNetCore.Identity.EntityFrameworkCore;
-// Importation du namespace pour Entity Framework Core qui permet l'accès aux bases de données.
-using Microsoft.EntityFrameworkCore;
-
-// Déclaration de la classe ApplicationDbContext qui hérite de IdentityDbContext.
-// IdentityDbContext est une classe spéciale fournie par ASP.NET Core Identity qui
-// étend DbContext (le contexte de base de données d'Entity Framework) et inclut
-// toutes les entités nécessaires pour la gestion des utilisateurs, rôles, et autres
-// fonctionnalités d'ASP.NET Core Identity. Nous utilisons ApplicationUser comme
-// modèle utilisateur personnalisé.
-public class ApplicationDbContext : IdentityDbContext<ApplicationUser>
-{
-    // Constructeur de la classe ApplicationDbContext qui appelle le constructeur de la classe parente (base).
-    // Il prend en paramètre un DbContextOptions, qui contient les informations nécessaires pour
-    // configurer le contexte, comme la chaîne de connexion à la base de données.
-    public ApplicationDbContext(DbContextOptions<ApplicationDbContext> options) : base(options)
-    {
-        // Le corps du constructeur est vide ici, car toute la logique de configuration
-        // est gérée par la classe de base (IdentityDbContext) et les options passées.
-    }
-    public DbSet<BookMagazine> BooksMagazines { get; set; }  // Ajout de la table pour les livres et magazines
-    public DbSet<Author> Authors { get; set; }  // Ajout de la table Author
-    public DbSet<Category> Categories { get; set; }  // Ajout de la table Category
-
-}
-
-```
-
-### 4. **Modèle pour l'upload du livre/magazine :**
-Ajoutons un modèle pour gérer les uploads de fichiers dans le contrôleur.
-
-#### `BookMagazineModel.cs` :
-```csharp
-using Microsoft.AspNetCore.Http;
-using System.ComponentModel.DataAnnotations;
-
-public class BookMagazineModel
-{
-    [Required]
-    public string Title { get; set; }
-
-    [Required]
-    public string Author { get; set; }  // L'auteur est désormais un champ texte
-
-    public string Description { get; set; }
-
-    [Required]
-    public string Category { get; set; }  // La catégorie est désormais un champ texte
-
-    public string Tags { get; set; }
-
-    [Required]
-    public IFormFile File { get; set; }
-
-    public IFormFile CoverImage { get; set; }  // Optionnel, image de couverture
-}
-```
-
-### 5. **Création d'un contrôleur pour gérer les livres et magazines :**
-
-Créons un contrôleur API pour ajouter, consulter, et télécharger des livres ou magazines.
-
-#### `BookMagazineController.cs` :
-```csharp
-using Microsoft.AspNetCore.Authorization;
-using Microsoft.AspNetCore.Mvc;
-using System.IO;
-using System.Linq;
-using System.Threading.Tasks;
-
-[Route("api/[controller]")]
-[ApiController]
-public class BookMagazineController : ControllerBase
-{
-    private readonly ApplicationDbContext _context;
-
-    public BookMagazineController(ApplicationDbContext context)
-    {
-        _context = context;
-    }
-
-    // *** Ajouter un livre ou magazine avec un auteur et une catégorie ***
-    [HttpPost("add")]
-    [Authorize]
-    public async Task<IActionResult> AddBookMagazine([FromForm] BookMagazineModel model)
-    {
-        // Vérifier si l'auteur existe, sinon le créer
-        var author = _context.Authors.FirstOrDefault(a => a.Name == model.Author);
-        if (author == null)
-        {
-            author = new Author { Name = model.Author };
-            _context.Authors.Add(author);
-            await _context.SaveChangesAsync();
-        }
-
-        // Vérifier si la catégorie existe, sinon la créer
-        var category = _context.Categories.FirstOrDefault(c => c.Name == model.Category);
-        if (category == null)
-        {
-            category = new Category { Name = model.Category };
-            _context.Categories.Add(category);
-            await _context.SaveChangesAsync();
-        }
-
-        // Enregistrement du fichier du livre/magazine
-        var filePath = Path.Combine("wwwroot/files", model.File.FileName);
-        using (var stream = new FileStream(filePath, FileMode.Create))
-        {
-            await model.File.CopyToAsync(stream);
-        }
-
-        // Enregistrement de l'image de couverture si elle est présente
-        string coverImagePath = null;
-        if (model.CoverImage != null && model.CoverImage.Length > 0)
-        {
-            coverImagePath = Path.Combine("wwwroot/images/covers", model.CoverImage.FileName);
-            using (var coverStream = new FileStream(coverImagePath, FileMode.Create))
-            {
-                await model.CoverImage.CopyToAsync(coverStream);
-            }
-            coverImagePath = $"/images/covers/{model.CoverImage.FileName}";
-        }
-
-        // Création de l'objet BookMagazine
-        var bookMagazine = new BookMagazine
-        {
-            Title = model.Title,
-            AuthorId = author.Id,  // Association avec l'auteur
-            CategoryId = category.Id,  // Association avec la catégorie
-            Description = model.Description,
-            Tags = model.Tags,
-            FilePath = $"/files/{model.File.FileName}",
-            CoverImagePath = coverImagePath
-        };
-
-        // Enregistrement dans la base de données
-        _context.BooksMagazines.Add(bookMagazine);
-        await _context.SaveChangesAsync();
-
-        return Ok(new { Message = "Book or magazine added successfully!", CoverImageUrl = coverImagePath });
-    }
-
-    // *** Obtenir la liste des livres ou magazines ***
-    [HttpGet("list")]
-    public IActionResult GetBooksMagazines()
-    {
-        var booksMagazines = _context.BooksMagazines
-            .Select(b => new
-            {
-                b.Id,
-                b.Title,
-                Author = b.Author.Name,
-                Category = b.Category.Name,
-                b.CoverImagePath,
-                b.UploadDate
-            })
-            .ToList();
-
-        return Ok(booksMagazines);
-    }
-
-    // *** Obtenir les détails d'un livre ou magazine spécifique ***
-    [HttpGet("{id}")]
-    public IActionResult GetBookMagazine(int id)
-    {
-        var bookMagazine = _context.BooksMagazines
-            .Where(b => b.Id == id)
-            .Select(b => new
-            {
-                b.Id,
-                b.Title,
-                b.Description,
-                Author = b.Author.Name,
-                Category = b.Category.Name,
-                b.Tags,
-                b.CoverImagePath,
-                b.FilePath,
-                b.UploadDate
-            })
-            .FirstOrDefault();
-
-        if (bookMagazine == null)
-            return NotFound();
-
-        return Ok(bookMagazine);
-    }
-
-    // *** Télécharger le fichier d'un livre ou magazine ***
-    [HttpGet("download/{id}")]
-    public IActionResult DownloadBookMagazine(int id)
-    {
-        var bookMagazine = _context.BooksMagazines.FirstOrDefault(b => b.Id == id);
-        if (bookMagazine == null) return NotFound();
-
-        var filePath = Path.Combine(Directory.GetCurrentDirectory(), "wwwroot", bookMagazine.FilePath.TrimStart('/'));
-        if (!System.IO.File.Exists(filePath))
-            return NotFound("File not found on server.");
-
-        var fileBytes = System.IO.File.ReadAllBytes(filePath);
-        var fileName = Path.GetFileName(filePath);
-
-        return File(fileBytes, "application/octet-stream", fileName);
-    }
-
-    // *** Mettre à jour un livre ou magazine par l'administrateur ***
-    [HttpPut("update/{id}")]
-    [Authorize(Roles = "Admin")]  // Seuls les administrateurs peuvent modifier
-    public async Task<IActionResult> UpdateBookMagazine(int id, [FromForm] BookMagazineModel model)
-    {
-        var bookMagazine = _context.BooksMagazines.FirstOrDefault(b => b.Id == id);
-        if (bookMagazine == null) return NotFound();
-
-        // Mise à jour des propriétés du livre/magazine
-        bookMagazine.Title = model.Title;
-        bookMagazine.Description = model.Description;
-        bookMagazine.Tags = model.Tags;
-
-        // Gestion de l'auteur et de la catégorie
-        var author = _context.Authors.FirstOrDefault(a => a.Name == model.Author);
-        if (author == null)
-        {
-            author = new Author { Name = model.Author };
-            _context.Authors.Add(author);
-            await _context.SaveChangesAsync();
-        }
-        bookMagazine.AuthorId = author.Id;
-
-        var category = _context.Categories.FirstOrDefault(c => c.Name == model.Category);
-        if (category == null)
-        {
-            category = new Category { Name = model.Category };
-            _context.Categories.Add(category);
-            await _context.SaveChangesAsync();
-        }
-        bookMagazine.CategoryId = category.Id;
-
-        // Gestion du fichier (facultatif)
-        if (model.File != null)
-        {
-            var filePath = Path.Combine("wwwroot/files", model.File.FileName);
-            using (var stream = new FileStream(filePath, FileMode.Create))
-            {
-                await model.File.CopyToAsync(stream);
-            }
-            bookMagazine.FilePath = $"/files/{model.File.FileName}";
-        }
-
-        // Gestion de l'image de couverture (facultatif)
-        if (model.CoverImage != null)
-        {
-            var coverImagePath = Path.Combine("wwwroot/images/covers", model.CoverImage.FileName);
-            using (var coverStream = new FileStream(coverImagePath, FileMode.Create))
-            {
-                await model.CoverImage.CopyToAsync(coverStream);
-            }
-            bookMagazine.CoverImagePath = $"/images/covers/{model.CoverImage.FileName}";
-        }
-
-        _context.BooksMagazines.Update(bookMagazine);
-        await _context.SaveChangesAsync();
-
-        return Ok(new { Message = "Book or magazine updated successfully!" });
-    }
-
-    // *** Supprimer un livre ou magazine par l'administrateur ***
-    [HttpDelete("delete/{id}")]
-    [Authorize(Roles = "Admin")]  // Seuls les administrateurs peuvent supprimer
-    public async Task<IActionResult> DeleteBookMagazine(int id)
-    {
-        var bookMagazine = _context.BooksMagazines.FirstOrDefault(b => b.Id == id);
-        if (bookMagazine == null) return NotFound();
-
-        // Suppression des fichiers associés (livre/magazine et image de couverture)
-        if (!string.IsNullOrEmpty(bookMagazine.FilePath))
-        {
-            var filePath = Path.Combine(Directory.GetCurrentDirectory(), "wwwroot", bookMagazine.FilePath.TrimStart('/'));
-            if (System.IO.File.Exists(filePath))
-            {
-                System.IO.File.Delete(filePath);
-            }
-        }
-
-        if (!string.IsNullOrEmpty(bookMagazine.CoverImagePath))
-        {
-            var coverImagePath = Path.Combine(Directory.GetCurrentDirectory(), "wwwroot", bookMagazine.CoverImagePath.TrimStart('/'));
-            if (System.IO.File.Exists(coverImagePath))
-            {
-                System.IO.File.Delete(coverImagePath);
-            }
-        }
-
-        // Suppression du livre/magazine dans la base de données
-        _context.BooksMagazines.Remove(bookMagazine);
-        await _context.SaveChangesAsync();
-
-        return Ok(new { Message = "Book or magazine deleted successfully!" });
-    }
-}
-```
-
-
-### 6. **Ajout de migration et mise à jour de la base de données :**
-Il est maintenant nécessaire de créer une migration et d'appliquer cette dernière à la base de données.
-
-```bash
-dotnet ef migrations add AddBookMagazine
-dotnet ef database update
-```
-
-### 6. **Tests des nouvelles routes pour un utilisateur :**
-
-- **POST** `/api/BookMagazine/add` : pour ajouter un livre ou magazine: Lorsque vous ajoutez un livre ou magazine, le contrôleur vérifiera si l'auteur et la catégorie existent déjà. Si non, ils seront créés automatiquement.
-- Les champs `Author` et `Category` sont maintenant des entités séparées, et `BookMagazine` contient deux clés étrangères pointant vers ces tables.
-Avec cette implémentation, les auteurs et les catégories sont maintenant stockés dans des tables séparées. Lors de l'ajout d'un nouveau livre ou magazine, le système vérifie si l'auteur et la catégorie existent déjà et les crée si nécessaire. Cela permet de mieux organiser les données et d'éviter la duplication des informations.
-
-- **GET** `/api/BookMagazine/list` : pour obtenir la liste des livres et magazines.
-- **GET** `/api/BookMagazine/{id}` : pour obtenir les détails d'un livre ou magazine.
-- **GET** `/api/BookMagazine/download/{id}` : pour télécharger un fichier.
-
-Cela permettra de gérer les livres et magazines dans l'API.
-
-### Explications des fonctionnalités ADMIN :
-
-1. **Modification d'un livre ou magazine** :
-   - Route : `PUT /api/BookMagazine/update/{id}`
-   - Seuls les administrateurs peuvent modifier un livre ou un magazine.
-   - Les champs comme le titre, l'auteur, la description, la catégorie, les tags, le fichier et l'image de couverture peuvent être mis à jour.
-   - L'ID du livre ou du magazine est utilisé pour identifier l'élément à modifier.
-
-2. **Suppression d'un livre ou magazine** :
-   - Route : `DELETE /api/BookMagazine/delete/{id}`
-   - Seuls les administrateurs peuvent supprimer un livre ou un magazine.
-   - Lorsque l'élément est supprimé, les fichiers (le document et l'image de couverture) sont également supprimés du serveur.
-
-### Tests des fonctionnalités ADMIN :
-
-- **PUT** `/api/BookMagazine/update/{id}` : Pour modifier un livre ou magazine en tant qu'administrateur.
-- **DELETE** `/api/BookMagazine/delete/{id}` : Pour supprimer un livre ou magazine en tant qu'administrateur.
-
-### Remarques :
-- Ces routes nécessitent que l'utilisateur ait le rôle **Admin** pour être accessibles.
-- Les fichiers sur le serveur (livre/magazine et image de couverture) sont également supprimés lors de la suppression de l'élément.
-
-
diff --git a/docs/Partie_03_Bibliotheque_personnelle.md b/docs/Partie_03_Bibliotheque_personnelle.md
deleted file mode 100644
index 1ad0a12..0000000
--- a/docs/Partie_03_Bibliotheque_personnelle.md
+++ /dev/null
@@ -1,507 +0,0 @@
- 
-Les étapes 1 et 2 que nous avons explorées jusqu'à présent couvrent effectivement deux grands aspects de notre application :
-
-1. **La gestion des utilisateurs** à travers **ASP.NET Identity** :
-   - Inscription, connexion, et gestion des rôles.
-   - Autorisations basées sur les rôles pour limiter l'accès à certaines fonctionnalités de l'application.
-
-2. **La gestion des livres et magazines** :
-   - Un ensemble de contrôleurs API permettant de gérer les livres et magazines, incluant l'ajout, la modification, la suppression, et la consultation des ouvrages.
-   - Ces fonctionnalités permettent de construire une base de données d'ouvrages accessible via des requêtes HTTP.
-
-### Étape 3 : Bibliothèque Personnelle
-
-Pour aller plus loin, nous allons maintenant enrichir l'application avec une **bibliothèque personnelle**. L'idée est de permettre à chaque utilisateur d'ajouter des livres ou des magazines à ses favoris et de suivre l'historique de ses lectures. Ces fonctionnalités introduisent des aspects personnalisés dans l'application, renforçant l'interaction utilisateur avec le contenu.
-
-Chaque fonctionnalité sera envisagée comme suit :
-
-#### 1. **Favoris**
-
-##### Idée d'implémentation :
-- **Conception de la base de données** : 
-  - Créer une nouvelle table dans la base de données appelée `UserFavorites`, qui liera les utilisateurs aux livres ou magazines qu'ils souhaitent ajouter à leurs favoris.
-  - Cette table contiendra les colonnes suivantes : `UserId` (qui fait référence à la table des utilisateurs `AspNetUsers`), `BookMagazineId` (qui référence la table des livres ou magazines `BooksMagazines`), et une **clé primaire composite** basée sur `UserId` et `BookMagazineId`.
-
-- **API pour les favoris** : 
-  - Un nouveau contrôleur API (`FavoritesController`) sera créé pour permettre aux utilisateurs de gérer leurs favoris. Les principales actions incluront l'ajout d'un favori, la suppression d'un favori et la consultation de la liste des favoris d'un utilisateur.
-
-##### Exemple de méthodes dans `FavoritesController.cs` :
-- **Ajouter un favori** : `[HttpPost("add-favorite/{bookMagazineId}")]` pour permettre à l'utilisateur d'ajouter un livre ou magazine à sa liste de favoris.
-- **Récupérer les favoris** : `[HttpGet("my-favorites")]` pour permettre à l'utilisateur de récupérer la liste des ouvrages qu'il a ajoutés à ses favoris.
-
-#### 2. **Historique de lecture**
-
-##### Idée d'implémentation :
-- **Conception de la base de données** :
-  - Créer une table `UserReadingHistory` qui enregistrera l'historique des lectures de chaque utilisateur. Les colonnes incluront : `UserId`, `BookMagazineId`, `LastReadDate`, pour suivre quel utilisateur a consulté quel livre/magazine et à quel moment.
-  - Cette fonctionnalité permettra aux utilisateurs de visualiser quels livres ou magazines ils ont déjà consultés et à quelle date.
-
-- **API pour l'historique de lecture** :
-  - Un contrôleur API (`ReadingHistoryController`) sera mis en place pour permettre aux utilisateurs de suivre leur historique de lecture et de mettre à jour cet historique lorsqu'ils consultent un livre ou un magazine.
-
-##### Exemple de méthodes dans `ReadingHistoryController.cs` :
-- **Récupérer l'historique de lecture** : `[HttpGet("reading-history")]` pour afficher à l'utilisateur la liste des livres ou magazines qu'il a consultés.
-- **Mettre à jour l'historique de lecture** : `[HttpPost("update-history/{bookMagazineId}")]` pour ajouter un livre/magazine à l'historique de lecture d'un utilisateur une fois qu'il l'a consulté.
-
-
-### Tutoriel : Ajouter une fonctionnalité de Favoris et d'Historique de lecture (Partie 3)
-
-Ce tutoriel décrit comment passer de la partie 2 à la partie 3 en ajoutant une bibliothèque personnelle, comprenant la gestion des favoris et de l'historique de lecture dans une API REST en ASP.NET Core. Nous supposerons que vous avez déjà suivi la partie 1 et la partie 2, et que l'environnement de développement et la base de données sont déjà configurés.
-
-#### 1. **Ajouter les modèles pour les favoris et l'historique de lecture**
-
-Dans le dossier **Models**, créez deux nouvelles classes : `UserFavorite` et `UserReadingHistory`.
-
-```csharp
-public class UserFavorite
-{
-    public string UserId { get; set; }  // ID de l'utilisateur
-    public ApplicationUser User { get; set; }  // Référence à l'utilisateur
-
-    public int BookMagazineId { get; set; }  // ID du livre ou magazine
-    public BookMagazine BookMagazine { get; set; }  // Référence au livre ou magazine
-}
-
-
-public class UserReadingHistory
-{
-    public string UserId { get; set; }  // ID de l'utilisateur
-    public ApplicationUser User { get; set; }  // Référence à l'utilisateur
-
-    public int BookMagazineId { get; set; }  // ID du livre ou magazine
-    public BookMagazine BookMagazine { get; set; }  // Référence au livre ou magazine
-
-    public DateTime LastReadDate { get; set; }  // Date de la dernière consultation
-}
-
-```
-
-Ces modèles représentent les favoris et l'historique de lecture d'un utilisateur. Ils contiennent une référence à l'utilisateur et au livre ou magazine.
-
-#### 2. **Modifier le contexte de la base de données (ApplicationDbContext)**
-
-Ensuite, ajoutez ces nouveaux modèles dans le contexte de la base de données (**ApplicationDbContext.cs**) et configurez les clés primaires composites.
-
-```csharp
-// Importation du namespace nécessaire pour utiliser Identity avec Entity Framework Core.
-// Identity permet la gestion des utilisateurs, rôles, connexions, etc.
-using Microsoft.AspNetCore.Identity.EntityFrameworkCore;
-// Importation du namespace pour Entity Framework Core qui permet l'accès aux bases de données.
-using Microsoft.EntityFrameworkCore;
-
-// Déclaration de la classe ApplicationDbContext qui hérite de IdentityDbContext.
-// IdentityDbContext est une classe spéciale fournie par ASP.NET Core Identity qui
-// étend DbContext (le contexte de base de données d'Entity Framework) et inclut 
-// toutes les entités nécessaires pour la gestion des utilisateurs, rôles, et autres
-// fonctionnalités d'ASP.NET Core Identity. Nous utilisons ApplicationUser comme 
-// modèle utilisateur personnalisé.
-public class ApplicationDbContext : IdentityDbContext<ApplicationUser>
-{
-    // Constructeur de la classe ApplicationDbContext qui appelle le constructeur de la classe parente (base).
-    // Il prend en paramètre un DbContextOptions, qui contient les informations nécessaires pour
-    // configurer le contexte, comme la chaîne de connexion à la base de données.
-    public ApplicationDbContext(DbContextOptions<ApplicationDbContext> options) : base(options)
-    {
-        // Le corps du constructeur est vide ici, car toute la logique de configuration 
-        // est gérée par la classe de base (IdentityDbContext) et les options passées. 
-    }
-    public DbSet<BookMagazine> BooksMagazines { get; set; }  // Ajout de la table pour les livres et magazines
-    public DbSet<Author> Authors { get; set; }  // Ajout de la table Author
-    public DbSet<Category> Categories { get; set; }  // Ajout de la table Category
-
-
-    // Nouvelles tables ajoutées pour l'étape 3 (Bibliothèque Personnelle)
-    public DbSet<UserFavorite> UserFavorites { get; set; }  // Ajout de la table pour les favoris de l'utilisateur
-    public DbSet<UserReadingHistory> UserReadingHistory { get; set; }  // Ajout de la table pour l'historique de lecture
-
-    // Surcharge de la méthode OnModelCreating pour configurer les clés primaires composites
-    protected override void OnModelCreating(ModelBuilder modelBuilder)
-    {
-        base.OnModelCreating(modelBuilder);  // Appel de la méthode de la classe de base
-
-        // Configuration de la clé primaire composite pour UserFavorite
-        modelBuilder.Entity<UserFavorite>()
-            .HasKey(uf => new { uf.UserId, uf.BookMagazineId });
-
-        // Configuration de la clé primaire composite pour UserReadingHistory
-        modelBuilder.Entity<UserReadingHistory>()
-            .HasKey(urh => new { urh.UserId, urh.BookMagazineId });
-    }
-}
-
-```
-
-Cela permet d'ajouter les tables `UserFavorites` et `UserReadingHistory` à la base de données, ainsi que la gestion des clés composites.
-
-#### 3. **Créer le contrôleur des favoris**
-
-Créez un nouveau contrôleur nommé `FavoritesController`. Ce contrôleur permettra à l'utilisateur de gérer ses favoris (ajout, récupération et suppression).
-
-```csharp
-using Microsoft.AspNetCore.Authorization;  // Nécessaire pour gérer l'authentification et l'autorisation des utilisateurs.
-using Microsoft.AspNetCore.Mvc;            // Fournit les outils pour créer des API RESTful, comme les contrôleurs et les actions HTTP (GET, POST, etc.).
-using Microsoft.EntityFrameworkCore;       // Permet d'utiliser Entity Framework Core pour interagir avec la base de données via le contexte de données (ApplicationDbContext).
-using System.Security.Claims;              // Utilisé pour manipuler les informations des utilisateurs (claims) dans les tokens d'authentification, comme l'identifiant de l'utilisateur (UserId).
-
-
-namespace LibraryAPI.Controllers
-{
-    [ApiController]
-    [Route("api/[controller]")]
-    [Authorize] // Cette annotation assure que toutes les actions dans ce contrôleur nécessitent une authentification.
-    public class FavoritesController : ControllerBase
-    {
-        // Dépendance à l'ApplicationDbContext pour interagir avec la base de données.
-        private readonly ApplicationDbContext _context;
-
-        // Le constructeur injecte le contexte de la base de données via l'injection de dépendances.
-        public FavoritesController(ApplicationDbContext context)
-        {
-            _context = context;
-        }
-
-        // Ajouter un livre/magazine aux favoris
-        [HttpPost("add-favorite/{bookMagazineId}")]
-        public async Task<IActionResult> AddFavorite(int bookMagazineId)
-        {
-            // Récupérer l'identifiant de l'utilisateur connecté via les Claims (informations stockées dans le token d'authentification).
-            var userId = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
-            
-            // Si l'utilisateur n'est pas authentifié, retourner un statut 401 (Unauthorized).
-            if (userId == null)
-            {
-                return Unauthorized();
-            }
-
-            // Rechercher dans la base de données si le livre/magazine existe avec l'ID fourni.
-            var bookMagazine = await _context.BooksMagazines.FindAsync(bookMagazineId);
-            
-            // Si le livre/magazine n'est pas trouvé, retourner une réponse 404 (Not Found) avec un message.
-            if (bookMagazine == null)
-            {
-                return NotFound(new { message = $"Book or magazine with ID {bookMagazineId} not found." });
-            }
-
-            // Vérifier si ce favori existe déjà pour cet utilisateur (empêcher les doublons).
-            var existingFavorite = await _context.UserFavorites
-                .FirstOrDefaultAsync(f => f.UserId == userId && f.BookMagazineId == bookMagazineId);
-
-            // Si le favori existe déjà, retourner un code 409 (Conflict) avec un message approprié.
-            if (existingFavorite != null)
-            {
-                return Conflict(new { message = "This item is already in your favorites." });
-            }
-
-            // Ajouter un nouveau favori pour l'utilisateur dans la table UserFavorites.
-            var userFavorite = new UserFavorite
-            {
-                UserId = userId,
-                BookMagazineId = bookMagazineId
-            };
-
-            // Sauvegarder le nouveau favori dans la base de données.
-            await _context.UserFavorites.AddAsync(userFavorite);
-            await _context.SaveChangesAsync();
-
-            // Retourner un message de succès avec un statut 200 (OK).
-            return Ok(new { message = "Book or magazine successfully added to favorites." });
-        }
-
-        // Récupérer la liste des favoris de l'utilisateur connecté
-        [HttpGet("my-favorites")]
-        public async Task<IActionResult> GetMyFavorites()
-        {
-            // Récupérer l'identifiant de l'utilisateur connecté via les Claims.
-            var userId = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
-            
-            // Si l'utilisateur n'est pas authentifié, retourner un statut 401 (Unauthorized).
-            if (userId == null)
-            {
-                return Unauthorized();
-            }
-
-            // Récupérer les favoris de l'utilisateur dans la table UserFavorites et inclure les détails des livres/magazines associés.
-            var favorites = await _context.UserFavorites
-                .Where(f => f.UserId == userId)
-                .Include(f => f.BookMagazine) // Inclure les informations du livre ou magazine lié.
-                .ToListAsync();
-
-            // Si aucun favori n'est trouvé, retourner une réponse 404 (Not Found).
-            if (favorites == null || !favorites.Any())
-            {
-                return NotFound(new { message = "No favorites found for the user." });
-            }
-
-            // Créer une réponse personnalisée, en s'assurant que les informations sur les livres/magazines ne sont pas nulles.
-            var response = favorites
-                .Where(f => f.BookMagazine != null) // Filtrer les résultats pour s'assurer que les livres/magazines ne sont pas nulls.
-                .Select(f => new
-                {
-                    BookMagazineId = f.BookMagazineId,
-                    Title = f.BookMagazine?.Title ?? "Unknown Title",
-                    Author = f.BookMagazine?.Author?.Name ?? "Unknown Author",
-                    Description = f.BookMagazine?.Description ?? "No Description Available",
-                    CoverImagePath = f.BookMagazine?.CoverImagePath ?? "No Cover Image Available",
-                    UploadDate = f.BookMagazine?.UploadDate ?? DateTime.MinValue
-                })
-                .ToList();
-
-            // Retourner la liste des favoris avec un statut 200 (OK).
-            return Ok(response);
-        }
-
-        // Supprimer un livre/magazine des favoris
-        [HttpDelete("remove-favorite/{bookMagazineId}")]
-        public async Task<IActionResult> RemoveFavorite(int bookMagazineId)
-        {
-            // Récupérer l'identifiant de l'utilisateur connecté via les Claims.
-            var userId = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
-            
-            // Si l'utilisateur n'est pas authentifié, retourner un statut 401 (Unauthorized).
-            if (userId == null)
-            {
-                return Unauthorized();
-            }
-
-            // Rechercher le favori correspondant à cet utilisateur et ce livre/magazine.
-            var favorite = await _context.UserFavorites
-                .FirstOrDefaultAsync(f => f.UserId == userId && f.BookMagazineId == bookMagazineId);
-
-            // Si le favori n'est pas trouvé, retourner une réponse 404 (Not Found).
-            if (favorite == null)
-            {
-                return NotFound(new { message = "The specified book or magazine is not in your favorites." });
-            }
-
-            // Supprimer le favori de la base de données.
-            _context.UserFavorites.Remove(favorite);
-            await _context.SaveChangesAsync();
-
-            // Retourner un message de succès avec un statut 200 (OK).
-            return Ok(new { message = "Book/Magazine removed from favorites successfully!" });
-        }
-    }
-}
-
-```
-
-#### 4. **Créer le contrôleur de l'historique de lecture**
-
-Ajoutez également un contrôleur `ReadingHistoryController` pour gérer l'historique de lecture.
-
-```csharp
-// Les directives 'using' ci-dessous permettent d'importer les namespaces nécessaires à la création du contrôleur et à la gestion des autorisations et des accès aux données.
-
-using Microsoft.AspNetCore.Authorization;  // Nécessaire pour gérer l'authentification et l'autorisation des utilisateurs dans l'application via des attributs comme [Authorize].
-using Microsoft.AspNetCore.Mvc;            // Fournit les outils essentiels pour créer des contrôleurs API, gérer les routes HTTP et les actions telles que GET, POST, PUT, DELETE.
-using Microsoft.EntityFrameworkCore;       // Permet l'utilisation d'Entity Framework Core pour interagir avec la base de données et effectuer des opérations CRUD.
-                                           
-// using System.IdentityModel.Tokens.Jwt;   // Commenté car non utilisé. Ce namespace est utile pour manipuler les JWT (JSON Web Tokens) directement si nécessaire.
-                                           
-using System.Security.Claims;              // Utilisé pour extraire des informations de l'utilisateur connecté (via les claims, comme l'identifiant d'utilisateur) à partir de son token d'authentification.
-
-
-namespace LibraryAPI.Controllers
-{
-    [ApiController]
-    [Route("api/[controller]")]
-    [Authorize] // Nécessite que l'utilisateur soit authentifié pour accéder à toutes les actions de ce contrôleur.
-    public class ReadingHistoryController : ControllerBase
-    {
-        // Dépendance injectée pour interagir avec la base de données via le contexte ApplicationDbContext.
-        private readonly ApplicationDbContext _context;
-
-        // Constructeur permettant d'injecter le contexte de base de données dans le contrôleur via l'injection de dépendances.
-        public ReadingHistoryController(ApplicationDbContext context)
-        {
-            _context = context;
-        }
-
-        // Ajouter un livre/magazine à l'historique de lecture
-        [HttpPost("update-history/{bookMagazineId}")]
-        public async Task<IActionResult> UpdateReadingHistory(int bookMagazineId)
-        {
-            // Récupérer l'identifiant de l'utilisateur à partir des Claims dans le token d'authentification.
-            var userId = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
-            
-            // Si l'utilisateur n'est pas authentifié, retourner un statut 401 (Unauthorized).
-            if (userId == null)
-            {
-                return Unauthorized();
-            }
-
-            // Vérifier si le livre ou magazine existe dans la base de données avant de l'ajouter à l'historique de lecture.
-            var bookMagazine = await _context.BooksMagazines.FindAsync(bookMagazineId);
-            if (bookMagazine == null)
-            {
-                // Si le livre/magazine n'existe pas, retourner une réponse 404 (Not Found).
-                return NotFound(new { message = $"Book or magazine with ID {bookMagazineId} not found." });
-            }
-
-            // Vérifier si cet utilisateur a déjà une entrée d'historique pour ce livre/magazine.
-            var readingHistory = await _context.UserReadingHistory
-                .FirstOrDefaultAsync(rh => rh.UserId == userId && rh.BookMagazineId == bookMagazineId);
-
-            if (readingHistory == null)
-            {
-                // Si aucune entrée n'existe, créer une nouvelle entrée pour cet utilisateur dans l'historique de lecture.
-                readingHistory = new UserReadingHistory
-                {
-                    UserId = userId,
-                    BookMagazineId = bookMagazineId,
-                    LastReadDate = DateTime.UtcNow
-                };
-                _context.UserReadingHistory.Add(readingHistory);
-            }
-            else
-            {
-                // Si une entrée existe déjà, mettre à jour la date de dernière lecture.
-                readingHistory.LastReadDate = DateTime.UtcNow;
-                _context.UserReadingHistory.Update(readingHistory);
-            }
-
-            // Sauvegarder les modifications dans la base de données.
-            await _context.SaveChangesAsync();
-
-            // Retourner une réponse avec un message de succès.
-            return Ok(new { message = "Reading history updated successfully!" });
-        }
-
-        // Récupérer l'historique de lecture de l'utilisateur
-        [HttpGet("reading-history")]
-        public async Task<IActionResult> GetReadingHistory()
-        {
-            // Récupérer l'identifiant de l'utilisateur à partir des Claims dans le token d'authentification.
-            var userId = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
-            
-            // Si l'utilisateur n'est pas authentifié, retourner un statut 401 (Unauthorized).
-            if (userId == null)
-            {
-                return Unauthorized();
-            }
-
-            // Récupérer l'historique de lecture de l'utilisateur depuis la base de données, y compris les détails des livres/magazines et de leurs auteurs.
-            var history = await _context.UserReadingHistory
-                .Where(rh => rh.UserId == userId)
-                .Include(rh => rh.BookMagazine) // Inclure les informations du livre ou magazine associé.
-                .ThenInclude(b => b.Author)     // Inclure également l'auteur du livre/magazine.
-                .OrderByDescending(rh => rh.LastReadDate) // Trier l'historique par date de dernière lecture (le plus récent en premier).
-                .ToListAsync();
-
-            // Si l'utilisateur n'a aucun historique de lecture, retourner une réponse 404 (Not Found).
-            if (history == null || !history.Any())
-            {
-                return NotFound(new { message = "No reading history found for the user." });
-            }
-
-            // Créer une réponse personnalisée en s'assurant que les informations sur les livres/magazines ne sont pas nulles.
-            var response = history
-                .Where(rh => rh.BookMagazine != null) // Vérifier que chaque livre/magazine n'est pas null.
-                .Select(rh => new
-                {
-                    BookMagazineId = rh.BookMagazineId,
-                    Title = rh.BookMagazine?.Title ?? "Unknown Title",
-                    Author = rh.BookMagazine?.Author?.Name ?? "Unknown Author",
-                    Description = rh.BookMagazine?.Description ?? "No Description Available",
-                    CoverImagePath = rh.BookMagazine?.CoverImagePath ?? "No Cover Image Available",
-                    LastReadDate = rh.LastReadDate
-                })
-                .ToList();
-
-            // Retourner l'historique de lecture de l'utilisateur avec un statut 200 (OK).
-            return Ok(response);
-        }
-    }
-}
-
-```
-
-#### 5. **Mise à jour de la base de données**
-
-Après avoir ajouté les nouvelles entités **UserFavorite** et **UserReadingHistory** dans le modèle de votre base de données, il est nécessaire de créer une migration afin que la base de données reflète ces modifications. Voici les étapes à suivre pour effectuer cette migration et mettre à jour la base de données.
-
-##### a. **Créer une migration**
-
-Ouvrez la **console du gestionnaire de package NuGet** ou le **terminal** de votre projet et exécutez la commande suivante pour créer une migration basée sur les nouvelles entités que nous avons ajoutées :
-
-```bash
-Add-Migration AddUserFavoritesAndReadingHistory
-```
-
-Cette commande va générer un fichier de migration qui inclura la création des tables `UserFavorites` et `UserReadingHistory` dans la base de données.
-
-##### b. **Vérifier la migration**
-
-Après avoir exécuté cette commande, vous verrez un fichier de migration créé dans le dossier **Migrations** de votre projet. Le fichier généré devrait contenir des instructions pour créer les tables `UserFavorites` et `UserReadingHistory`. Assurez-vous que la structure est correcte.
-
-##### c. **Mettre à jour la base de données**
-
-Une fois la migration créée, vous devez appliquer ces modifications à la base de données. Pour cela, exécutez la commande suivante :
-
-```bash
-Update-Database
-```
-
-Cette commande va appliquer la migration à votre base de données en ajoutant les nouvelles tables.
-
-##### d. **Vérification de la mise à jour**
-
-Vous pouvez vérifier si les tables ont bien été créées dans votre base de données en consultant votre serveur de base de données, par exemple en utilisant **SQL Server Management Studio** ou un outil équivalent pour visualiser la structure de la base de données. Vous devriez maintenant voir les tables `UserFavorites` et `UserReadingHistory` ajoutées.
-
-#### 6. **Tester avec Swagger**
-
-Une fois les contrôleurs et la base de données configurés, vous pouvez tester les nouvelles fonctionnalités à l'aide de **Swagger**, un outil intégré qui vous permet d'explorer et d'interagir avec votre API.
-
-##### a. **Lancer l'application**
-
-Assurez-vous que votre application est bien lancée en mode développement (ou avec l'option Swagger activée). Vous pouvez le faire en exécutant votre projet via Visual Studio, Rider, ou en ligne de commande avec :
-
-```bash
-dotnet run
-```
-
-Une fois l'application démarrée, Swagger sera généralement accessible à une URL similaire à `http://localhost:5000/swagger` ou `http://localhost:<port>/swagger`.
-
-##### b. **Explorer les nouvelles routes**
-
-Swagger générera automatiquement la documentation de l'API et l'interface utilisateur basée sur les contrôleurs que nous avons ajoutés, notamment :
-
-- **POST** `/api/favorites/add-favorite/{bookMagazineId}` : Ajouter un livre ou magazine aux favoris.
-- **GET** `/api/favorites/my-favorites` : Récupérer la liste des favoris de l'utilisateur.
-- **DELETE** `/api/favorites/remove-favorite/{bookMagazineId}` : Supprimer un livre ou magazine des favoris.
-
-- **POST** `/api/reading-history/update-history/{bookMagazineId}` : Ajouter ou mettre à jour un livre ou magazine dans l'historique de lecture.
-- **GET** `/api/reading-history/reading-history` : Récupérer l'historique de lecture de l'utilisateur.
-
-##### c. **Tester les requêtes**
-
-- **Ajouter un favori** : Utilisez la méthode `POST` avec un ID valide de `bookMagazineId` pour ajouter un livre ou un magazine aux favoris.
-- **Récupérer vos favoris** : Testez la méthode `GET` pour afficher la liste de vos favoris.
-- **Supprimer un favori** : Utilisez la méthode `DELETE` pour retirer un favori à l'aide de son `bookMagazineId`.
-- **Mettre à jour l'historique** : Testez la méthode `POST` pour ajouter ou mettre à jour l'historique de lecture.
-- **Récupérer l'historique de lecture** : Utilisez la méthode `GET` pour récupérer l'historique de lecture de l'utilisateur.
-
-##### d. **Vérifier les réponses**
-
-Swagger vous permet de voir les requêtes et réponses associées à chaque méthode. Par exemple :
-- Si vous ajoutez un favori, vous devriez recevoir une réponse de type `200 OK` avec un message confirmant l'ajout.
-- Si vous tentez d'ajouter un favori déjà existant, vous obtiendrez un code `409 Conflict`.
-- Si vous essayez de supprimer un favori inexistant, une réponse `404 Not Found` sera retournée.
-
-
-
-### Conclusion de l'étape 3 : Bibliothèque Personnelle
-
-Félicitations ! 🎉 Vous avez désormais ajouté avec succès la fonctionnalité de **bibliothèque personnelle** à votre application. Cette étape a permis d’enrichir l’expérience utilisateur en offrant la possibilité d'ajouter des livres et magazines à une liste de favoris, ainsi que de suivre l’historique de lecture.
-
-Grâce à cette nouvelle fonctionnalité, les utilisateurs peuvent désormais interagir de manière plus personnalisée avec le contenu de l’application, en conservant une trace de leurs lectures passées et en gérant leurs ouvrages préférés.
-
-### Ce que vous avez accompli :
-- La mise en place d’une table pour les **favoris** (`UserFavorites`), permettant aux utilisateurs d’ajouter et de gérer leurs ouvrages favoris.
-- La création d’une table pour l'**historique de lecture** (`UserReadingHistory`), permettant de suivre les livres et magazines consultés par les utilisateurs.
-- L’ajout de deux nouveaux contrôleurs API (`FavoritesController` et `ReadingHistoryController`) pour gérer ces nouvelles fonctionnalités.
-- L’utilisation de **Swagger** pour tester et valider vos nouvelles routes API.
-
-Avec ces fondations, votre application est prête à évoluer vers des fonctionnalités encore plus avancées comme la personnalisation de recommandations, l’intégration de notifications ou l’analyse des habitudes de lecture.
-
-Continuez à explorer et à améliorer votre projet. Bon développement ! 🚀
\ No newline at end of file
diff --git a/docs/Partie_04_recherche_filtres.md b/docs/Partie_04_recherche_filtres.md
deleted file mode 100644
index d576823..0000000
--- a/docs/Partie_04_recherche_filtres.md
+++ /dev/null
@@ -1,467 +0,0 @@
-
----
-
-## Tutoriel : Implémenter une recherche avancée et un tri par popularité dans une API REST avec ASP.NET Core
-
-Dans ce tutoriel, nous allons créer des fonctionnalités pour une API REST .NET permettant la gestion de livres et magazines. Nous allons notamment :
-
-1. **Ajouter et gérer des compteurs de vues et de téléchargements** pour les livres/magazines.
-2. **Implémenter une recherche avancée** avec filtres par auteur, catégorie, mots-clés, et date.
-3. **Trier les résultats par popularité** (vues ou téléchargements).
-4. **Proposer des suggestions** basées sur l'historique de lecture de l'utilisateur.
-
-### Prérequis
-- Avoir une API REST .NET Core fonctionnelle avec Entity Framework.
-- Un modèle de base de données pour les livres/magazines (`BooksMagazines`), auteurs (`Author`), catégories (`Category`), et l'historique de lecture.
-
----
-
-### 1. **Ajouter un compteur de vues et de téléchargements à la base de données**
-
-Dans ce tutoriel, chaque livre/magazine aura deux compteurs :
-- **ViewCount** : Nombre de vues.
-- **DownloadCount** : Nombre de téléchargements.
-
-#### Étape 1.1 : Modifier le modèle `BookMagazine`
-
-Commencez par modifier le modèle `BookMagazine` pour y ajouter les champs `ViewCount` et `DownloadCount`.
-
-```csharp
-public class BookMagazine
-{
-    public int Id { get; set; }
-    public string Title { get; set; }
-    public string Description { get; set; }
-    public string Tags { get; set; }
-    public string FilePath { get; set; }
-    public string CoverImagePath { get; set; }
-    public DateTime UploadDate { get; set; }
-
-    public int AuthorId { get; set; }
-    public Author Author { get; set; }
-
-    public int CategoryId { get; set; }
-    public Category Category { get; set; }
-
-    // Compteur de vues
-    public int ViewCount { get; set; } = 0;
-
-    // Compteur de téléchargements
-    public int DownloadCount { get; set; } = 0;
-}
-```
-
-#### Étape 1.2 : Créer et appliquer une migration
-
-Générez et appliquez une migration pour ajouter ces champs à votre base de données.
-
-```bash
-dotnet ef migrations add AddViewAndDownloadCountsToBooksMagazines
-dotnet ef database update
-```
-
----
-
-### 2. **Incrémenter le compteur de vues et de téléchargements**
-
-À chaque fois qu'un utilisateur consulte ou télécharge un livre ou magazine, nous devons incrémenter les compteurs correspondants.
-
-#### Étape 2.1 : Incrémenter le compteur de vues
-
-Modifiez l'action `GetBookMagazine` dans le contrôleur `BookMagazineController` pour incrémenter le compteur de vues.
-
-```csharp
-[HttpGet("{id}")]
-public async Task<IActionResult> GetBookMagazine(int id)
-{
-    var bookMagazine = await _context.BooksMagazines
-        .Include(b => b.Author)
-        .Include(b => b.Category)
-        .FirstOrDefaultAsync(b => b.Id == id);
-
-    if (bookMagazine == null)
-        return NotFound();
-
-    // Vérifier que les entités liées existent
-    if (bookMagazine.Author == null || bookMagazine.Category == null)
-        return StatusCode(500, "Invalid data: Author or Category not found.");
-
-    // Incrémenter le compteur de vues
-    bookMagazine.ViewCount++;
-    _context.BooksMagazines.Update(bookMagazine);
-    await _context.SaveChangesAsync();
-
-    return Ok(new {
-        bookMagazine.Id,
-        bookMagazine.Title,
-        bookMagazine.Description,
-        Author = bookMagazine.Author.Name,
-        Category = bookMagazine.Category.Name,
-        bookMagazine.Tags,
-        bookMagazine.CoverImagePath,
-        bookMagazine.FilePath,
-        bookMagazine.UploadDate,
-        bookMagazine.ViewCount
-    });
-}
-```
-
-#### Étape 2.2 : Incrémenter le compteur de téléchargements
-
-Ajoutez une action `DownloadBookMagazine` qui gère le téléchargement des fichiers et incrémente le compteur de téléchargements.
-
-```csharp
-[HttpGet("download/{id}")]
-public async Task<IActionResult> DownloadBookMagazine(int id)
-{
-    var bookMagazine = await _context.BooksMagazines
-        .FirstOrDefaultAsync(b => b.Id == id);
-
-    if (bookMagazine == null)
-        return NotFound();
-
-    // Incrémenter le compteur de téléchargements
-    bookMagazine.DownloadCount++;
-    _context.BooksMagazines.Update(bookMagazine);
-    await _context.SaveChangesAsync();
-
-    var filePath = Path.Combine(Directory.GetCurrentDirectory(), "wwwroot", bookMagazine.FilePath.TrimStart('/'));
-    if (!System.IO.File.Exists(filePath))
-        return NotFound("File not found on server.");
-
-    var fileBytes = System.IO.File.ReadAllBytes(filePath);
-    var fileName = Path.GetFileName(filePath);
-
-    return File(fileBytes, "application/octet-stream", fileName);
-}
-```
-
----
-
-### 3. **Recherche avancée avec tri par popularité**
-
-Nous allons maintenant ajouter des fonctionnalités de recherche avancée avec la possibilité de trier les résultats par popularité (vues ou téléchargements).
-
-#### Étape 3.1 : Recherche simple par mots-clés
-
-Cette méthode permet de rechercher des livres/magazines par titre, description, auteur, ou tags.
-
-```csharp
-[HttpGet("search")]
-public IActionResult SearchBooksMagazines([FromQuery] string keyword)
-{
-    var booksMagazines = _context.BooksMagazines
-        .Where(b => b.Title.Contains(keyword) ||
-                    b.Description.Contains(keyword) ||
-                    b.Author.Name.Contains(keyword) ||
-                    b.Tags.Contains(keyword))
-        .Select(b => new {
-            b.Id,
-            b.Title,
-            Author = b.Author.Name,
-            b.CoverImagePath,
-            b.UploadDate,
-            b.ViewCount
-        })
-        .ToList();
-
-    return Ok(booksMagazines);
-}
-```
-
-#### Étape 3.2 : Recherche avancée avec filtres et tri par popularité
-
-Nous ajoutons une méthode de recherche plus avancée avec la possibilité de filtrer par catégorie, auteur, mots-clés, et date de publication. On peut également trier par popularité (vues).
-
-```csharp
-[HttpGet("advanced-search")]
-public IActionResult SearchBooksMagazines([FromQuery] string keyword, [FromQuery] string category, [FromQuery] string author, [FromQuery] DateTime? publishDate, [FromQuery] bool sortByPopularity = false)
-{
-    var query = _context.BooksMagazines
-        .Include(b => b.Author)
-        .Include(b => b.Category)
-        .AsQueryable();
-
-    if (!string.IsNullOrEmpty(keyword))
-    {
-        query = query.Where(b => b.Title.Contains(keyword) ||
-                                 b.Description.Contains(keyword) ||
-                                 b.Tags.Contains(keyword));
-    }
-
-    if (!string.IsNullOrEmpty(category))
-    {
-        query = query.Where(b => b.Category.Name == category);
-    }
-
-    if (!string.IsNullOrEmpty(author))
-    {
-        query = query.Where(b => b.Author.Name == author);
-    }
-
-    if (publishDate.HasValue)
-    {
-        query = query.Where(b => b.UploadDate >= publishDate.Value);
-    }
-
-    // Trier par popularité (ViewCount) si demandé
-    if (sortByPopularity)
-    {
-        query = query.OrderByDescending(b => b.ViewCount);
-    }
-
-    var results = query.Select(b => new {
-        b.Id,
-        b.Title,
-        Author = b.Author.Name,
-        b.CoverImagePath,
-        b.UploadDate,
-        b.ViewCount
-    }).ToList();
-
-    return Ok(results);
-}
-```
-
-#### Étape 3.3 : Requête pour trier par vues et téléchargements
-
-Ajoutez des méthodes spécifiques pour trier les livres/magazines par popularité (vues ou téléchargements).
-
-- **Trier par vues** :
-
-```csharp
-[HttpGet("search/popular")]
-public IActionResult SearchBooksMagazinesByPopularity()
-{
-    var booksMagazines = _context.BooksMagazines
-        .OrderByDescending(b => b.ViewCount)
-        .Select(b => new {
-            b.Id,
-            b.Title,
-            Author = b.Author.Name,
-            b.CoverImagePath,
-            b.UploadDate,
-            b.ViewCount
-        })
-        .ToList();
-
-    return Ok(booksMagazines);
-}
-```
-
-- **Trier par téléchargements** :
-
-```csharp
-[HttpGet("search/popular-downloads")]
-public IActionResult SearchBooksMagazinesByDownloads()
-{
-    var booksMagazines = _context.BooksMagazines
-        .OrderByDescending(b => b.DownloadCount)
-        .Select(b => new {
-            b.Id,
-            b.Title,
-            Author = b.Author.Name,
-            b.CoverImagePath,
-            b.UploadDate,
-            b.DownloadCount
-        })
-        .ToList();
-
-    return Ok(booksMagazines);
-}
-```
-
----
-
-### 4. **Suggestions basées sur l'historique de lecture**
-
-Enfin, nous implémentons une fonctionnalité de suggestions pour l'utilisateur basée sur son historique de lecture.
-
-#### Étape 4.1 : Suggestions bas
-
-ées sur les catégories déjà lues
-
-Cette méthode va suggérer des livres ou magazines à l'utilisateur en fonction des catégories des livres qu'il a déjà consultés.
-
-```csharp
-[HttpGet("suggestions")]
-[Authorize]
-public IActionResult GetSuggestions()
-{
-    var userId = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
-
-    // Obtenez les catégories des livres déjà lus par l'utilisateur
-    var categories = _context.UserReadingHistory
-        .Where(ur => ur.UserId == userId)
-        .Select(ur => ur.BookMagazine.CategoryId)
-        .Distinct()
-        .ToList();
-
-    // Obtenez les suggestions basées sur ces catégories
-    var suggestions = _context.BooksMagazines
-        .Where(b => categories.Contains(b.CategoryId))
-        .Select(b => new {
-            b.Id,
-            b.Title,
-            Author = b.Author.Name,
-            b.CoverImagePath,
-            b.UploadDate
-        })
-        .ToList();
-
-    return Ok(suggestions);
-}
-```
-
----
-
-### 5. **Tester les fonctionnalités avec Swagger**
-
-Après avoir implémenté les différentes fonctionnalités de votre API, vous devez les tester. L'interface **Swagger** est un excellent outil pour cela, car elle permet de simuler des requêtes HTTP directement dans le navigateur.
-
-Swagger expose tous les endpoints de votre API et permet de tester les requêtes avec différents paramètres, y compris l'authentification avec un token JWT pour les actions protégées.
-
-#### Étape 5.1 : Accéder à Swagger
-
-Si Swagger est correctement configuré dans votre projet ASP.NET Core, vous pouvez y accéder via l'URL suivante :
-
-```
-http://localhost:5000/swagger/index.html
-```
-
-Remplacez `localhost:5000` par l'URL et le port sur lequel votre API s'exécute.
-
----
-
-### 5.2 : **Test des fonctionnalités**
-
-#### 5.2.1 : **Authentification JWT avec Bearer Token**
-
-Pour les actions protégées par l'authentification (comme les suggestions basées sur l'historique de lecture), vous devez fournir un **Bearer Token** dans les en-têtes de vos requêtes. Voici comment obtenir ce token et l'utiliser dans Swagger.
-
-##### Obtenir le token JWT
-- Allez dans l'endpoint `POST /api/Auth/login` dans Swagger.
-- Fournissez vos identifiants d'utilisateur (email et mot de passe) dans le corps de la requête.
-- Cliquez sur **Execute** pour envoyer la requête.
-
-Swagger vous renverra une réponse JSON contenant un **token JWT** similaire à ceci :
-
-```json
-{
-  "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiI5YWQ1MjRkYS05ZmIyLTRlY2EtOWQ1My1kOGVhOTQzMTgyZTIiLCJlbWFpbCI6Im5peEBuaXguZnIiLCJodHRwOi8vc2NoZW1hcy54bWxzb2FwLm9yZy93cy8yMDA1LzA1L2lkZW50aXR5L2NsYWltcy9uYW1lIjoibml4QG5peC5mciIsImV4cCI6MTY4MjIxMTU5MCwiaXNzIjoiTGlicmFyeUFwaSIsImF1ZCI6IkxpYnJhcnlBcGlVc2VycyJ9.abc1234xyz5678"
-}
-```
-
-##### Ajouter le Bearer Token dans Swagger
-
-1. Copiez le token reçu lors de l'authentification.
-2. En haut à droite de Swagger, vous verrez un bouton **Authorize**. Cliquez dessus.
-3. Dans le champ `Authorization`, entrez le token avec le format suivant :
-   ```
-   Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiI5YWQ1MjRkYS05ZmIyLTRlY2EtOWQ1My1kOGVhOTQzMTgyZTIiLCJlbWFpbCI6Im5peEBuaXguZnIiLCJodHRwOi8vc2NoZW1hcy54bWxzb2FwLm9yYy9jbGFpbXMvcm9sZSI6IlVzZXIiLCJleHAiOjE3MjkxOTM1MzcsImlzcyI6IkxpYnJhcnlBcGkiLCJhdWQiOiJMaWJyYXJ5QXBpVXNlcnMifQ.n-pzBOigRerO51e4PmAs3ET27ktpumCpfJO34BIS3S4
-   ```
-4. Cliquez sur **Authorize**. Swagger utilisera maintenant ce token pour toutes les requêtes nécessitant une authentification.
-
----
-
-#### 5.2.2 : **Tester les différents endpoints**
-
-Voici comment tester chaque fonctionnalité que vous avez implémentée avec Swagger.
-
-##### a) **Ajouter un livre ou magazine**
-
-- Allez à l'endpoint `POST /api/BookMagazine/add`.
-- Remplissez les champs requis :
-  - **Title** : Le titre du livre ou magazine.
-  - **Description** : Une description.
-  - **Tags** : Des mots-clés associés.
-  - **AuthorId** et **CategoryId** : Les ID de l'auteur et de la catégorie.
-  - **FilePath** : Le chemin du fichier.
-  - **CoverImagePath** : Le chemin de l'image de couverture.
-- Cliquez sur **Execute** pour envoyer la requête.
-
-##### b) **Lister les livres ou magazines**
-
-- Allez à l'endpoint `GET /api/BookMagazine/list`.
-- Cliquez sur **Execute** pour obtenir la liste des livres/magazines.
-
-##### c) **Détails d'un livre ou magazine**
-
-- Allez à l'endpoint `GET /api/BookMagazine/{id}`.
-- Remplacez `{id}` par l'ID du livre/magazine que vous souhaitez consulter.
-- Cliquez sur **Execute** pour obtenir les détails.
-
-##### d) **Télécharger un livre ou magazine**
-
-- Allez à l'endpoint `GET /api/BookMagazine/download/{id}`.
-- Remplacez `{id}` par l'ID du livre/magazine à télécharger.
-- Cliquez sur **Execute** pour tester le téléchargement du fichier.
-
-##### e) **Recherche simple**
-
-- Allez à l'endpoint `GET /api/BookMagazine/search`.
-- Saisissez un **keyword** dans les paramètres (ex : un mot-clé dans le titre, la description ou les tags).
-- Cliquez sur **Execute** pour obtenir les résultats de la recherche.
-
-##### f) **Recherche avancée**
-
-- Allez à l'endpoint `GET /api/BookMagazine/advanced-search`.
-- Remplissez les paramètres de recherche comme le **keyword**, **category**, **author**, **publishDate**, et **sortByPopularity** (ce dernier est un booléen pour trier par popularité).
-- Cliquez sur **Execute** pour voir les résultats filtrés.
-
-##### g) **Suggestions personnalisées**
-
-- Allez à l'endpoint `GET /api/BookMagazine/suggestions`.
-- Ce endpoint est protégé par un token JWT, donc assurez-vous d'avoir ajouté le **Bearer Token** comme expliqué dans la section précédente.
-- Cliquez sur **Execute** pour obtenir des suggestions basées sur l'historique de lecture de l'utilisateur connecté.
-
-##### h) **Recherche par popularité**
-
-- Allez à l'endpoint `GET /api/BookMagazine/search/popular` pour obtenir la liste triée par popularité (vues).
-- Ou utilisez `GET /api/BookMagazine/search/popular-downloads` pour trier par téléchargements.
-
----
-
-### 5.3 : **Vérifier les réponses**
-
-Swagger affichera les réponses de votre API sous forme de JSON, ce qui vous permettra de vérifier si les fonctionnalités fonctionnent correctement.
-
-Exemple de réponse pour une recherche :
-
-```json
-[
-  {
-    "id": 1,
-    "title": "Livre Exemple",
-    "author": "John Doe",
-    "coverImagePath": "/images/book1.jpg",
-    "uploadDate": "2023-10-17T00:00:00",
-    "viewCount": 123
-  },
-  {
-    "id": 2,
-    "title": "Magazine Exemple",
-    "author": "Jane Doe",
-    "coverImagePath": "/images/magazine1.jpg",
-    "uploadDate": "2023-10-17T00:00:00",
-    "viewCount": 98
-  }
-]
-```
-
----
-
-### Conclusion
-
-Nous avons implémenté plusieurs fonctionnalités dans cette API REST en ASP.NET Core :
-- Ajout de compteurs de vues et de téléchargements pour les livres/magazines.
-- Recherche avancée avec filtres par auteur, catégorie, et mots-clés.
-- Tri par popularité (vues ou téléchargements).
-- Suggestions personnalisées basées sur l'historique de lecture.
-
-Ces fonctionnalités sont idéales pour améliorer l'expérience utilisateur d'une bibliothèque numérique. Vous pouvez maintenant tester chacune d'entre elles en utilisant **Swagger** ou tout autre outil pour faire des requêtes HTTP (comme Postman).
-
-Swagger est un excellent outil pour tester et documenter vos API REST. Il permet d'interagir avec vos endpoints directement via l'interface web, facilitant ainsi le développement et le débogage. Avec le support du token JWT, vous pouvez également tester les fonctionnalités protégées par l'authentification dans un environnement sécurisé.
-
-
-
diff --git a/docs/Partie_05_commentaires_notes.md b/docs/Partie_05_commentaires_notes.md
deleted file mode 100644
index 21fb909..0000000
--- a/docs/Partie_05_commentaires_notes.md
+++ /dev/null
@@ -1,378 +0,0 @@
- 
-# Tutoriel : Ajout des fonctionnalités de Notes et Commentaires à votre API REST .NET
-
-Dans ce tutoriel, nous allons ajouter les fonctionnalités de **Notes** et **Commentaires** à une API REST .NET qui permet aux utilisateurs de stocker, consulter et télécharger des livres ou des magazines. Ces fonctionnalités permettront aux utilisateurs d'évaluer les livres/magazines et de partager leurs avis, créant ainsi une expérience communautaire enrichie.
-
-## Prérequis
-
-- Connaissances de base en C# et ASP.NET Core.
-- Un projet d'API REST .NET déjà configuré avec Entity Framework Core et une base de données (par exemple, SQL Server ou MySQL).
-- L'authentification des utilisateurs mise en place (par exemple, avec Identity).
-
-## Objectifs du tutoriel
-
-- Créer des modèles pour gérer les notes et les commentaires.
-- Mettre à jour le contexte de base de données pour inclure les nouveaux modèles.
-- Ajouter des migrations et mettre à jour la base de données.
-- Créer des routes d'API pour permettre aux utilisateurs de soumettre des notes et des commentaires.
-- Gérer l'affichage des notes moyennes et des commentaires associés aux livres/magazines.
-- S'assurer que seules les personnes authentifiées peuvent interagir avec ces fonctionnalités.
-
-## Étape 1 : Création des modèles de données
-
-### 1.1 Modèle `Rating`
-
-Le modèle `Rating` permettra de stocker les notes que chaque utilisateur attribue à un livre ou magazine.
-
-**Créer un fichier `Rating.cs` dans le dossier `Models` :**
-
-```csharp
-using System;
-using System.ComponentModel.DataAnnotations;
-
-public class Rating
-{
-    [Key]
-    public int Id { get; set; }
-
-    [Required]
-    public int BookMagazineId { get; set; }
-
-    [Required]
-    public string UserId { get; set; }  // ID de l'utilisateur
-
-    [Required]
-    [Range(1, 5)]
-    public int RatingValue { get; set; }  // La note (1 à 5 étoiles)
-
-    public DateTime RatingDate { get; set; } = DateTime.Now;
-
-    // Relations (facultatives)
-    public BookMagazine BookMagazine { get; set; }
-    public ApplicationUser User { get; set; }
-}
-```
-
-### 1.2 Modèle `Comment`
-
-Le modèle `Comment` permettra de gérer les commentaires et les réponses aux commentaires pour chaque livre ou magazine.
-
-**Créer un fichier `Comment.cs` dans le dossier `Models` :**
-
-```csharp
-using System;
-using System.ComponentModel.DataAnnotations;
-
-public class Comment
-{
-    [Key]
-    public int Id { get; set; }
-
-    [Required]
-    public int BookMagazineId { get; set; }
-
-    [Required]
-    public string UserId { get; set; }  // ID de l'utilisateur
-
-    [Required]
-    public string Content { get; set; }  // Contenu du commentaire
-
-    public DateTime CommentDate { get; set; } = DateTime.Now;
-
-    public int? ParentCommentId { get; set; }  // Pour les réponses (facultatif)
-
-    // Relations (facultatives)
-    public BookMagazine BookMagazine { get; set; }
-    public ApplicationUser User { get; set; }
-    public Comment ParentComment { get; set; }
-}
-```
-
-## Étape 2 : Mise à jour du contexte de base de données
-
-Pour que Entity Framework Core puisse créer les tables correspondantes, nous devons ajouter les nouveaux modèles au contexte de base de données.
-
-**Ouvrez `ApplicationDbContext.cs` et ajoutez les `DbSet` suivants :**
-
-```csharp
-using Microsoft.AspNetCore.Identity.EntityFrameworkCore;
-using Microsoft.EntityFrameworkCore;
-
-public class ApplicationDbContext : IdentityDbContext<ApplicationUser>
-{
-    // Constructeur existant...
-
-    public DbSet<BookMagazine> BooksMagazines { get; set; }
-    public DbSet<Author> Authors { get; set; }
-    public DbSet<Category> Categories { get; set; }
-
-    // Ajouter les DbSet pour Rating et Comment
-    public DbSet<Rating> Ratings { get; set; }
-    public DbSet<Comment> Comments { get; set; }
-}
-```
-
-## Étape 3 : Ajout de migrations et mise à jour de la base de données
-
-Après avoir ajouté les nouveaux modèles, nous devons créer une migration pour mettre à jour la base de données.
-
-**Dans la console du gestionnaire de packages (ou via la ligne de commande), exécutez :**
-
-```bash
-dotnet ef migrations add AddRatingsAndComments
-dotnet ef database update
-```
-
-Ces commandes vont créer les tables `Ratings` et `Comments` dans la base de données.
-
-## Étape 4 : Ajout des fonctionnalités de notation
-
-### 4.1 Modification du modèle `BookMagazine`
-
-Nous allons ajouter un champ `AverageRating` pour stocker la note moyenne de chaque livre ou magazine.
-
-**Ouvrez `BookMagazine.cs` et ajoutez la propriété suivante :**
-
-```csharp
-public class BookMagazine
-{
-    // Autres propriétés existantes...
-
-    public double AverageRating { get; set; }  // Note moyenne du livre/magazine
-}
-```
-
-**N'oubliez pas de créer une migration pour cette modification :**
-
-```bash
-dotnet ef migrations add AddAverageRatingToBookMagazine
-dotnet ef database update
-```
-
-### 4.2 Création des routes d'API pour les évaluations
-
-Nous allons permettre aux utilisateurs d'ajouter ou de mettre à jour leur note pour un livre ou magazine, et de récupérer les notes.
-
-**Ouvrez `BookMagazineController.cs` et ajoutez les méthodes suivantes :**
-
-#### Soumettre une note
-
-```csharp
-[HttpPost("{bookMagazineId}/rate")]
-[Authorize]
-public async Task<IActionResult> RateBookMagazine(int bookMagazineId, [FromBody] int ratingValue)
-{
-    var userId = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
-
-    if (ratingValue < 1 || ratingValue > 5)
-        return BadRequest("La note doit être comprise entre 1 et 5.");
-
-    // Vérifier si l'utilisateur a déjà noté ce livre/magazine
-    var existingRating = await _context.Ratings
-        .FirstOrDefaultAsync(r => r.BookMagazineId == bookMagazineId && r.UserId == userId);
-
-    if (existingRating != null)
-    {
-        // Mettre à jour la note existante
-        existingRating.RatingValue = ratingValue;
-        existingRating.RatingDate = DateTime.Now;
-    }
-    else
-    {
-        // Ajouter une nouvelle note
-        var rating = new Rating
-        {
-            BookMagazineId = bookMagazineId,
-            UserId = userId,
-            RatingValue = ratingValue
-        };
-        _context.Ratings.Add(rating);
-    }
-
-    await _context.SaveChangesAsync();
-
-    // Recalculer la note moyenne
-    var averageRating = await _context.Ratings
-        .Where(r => r.BookMagazineId == bookMagazineId)
-        .AverageAsync(r => r.RatingValue);
-
-    // Mettre à jour la note moyenne dans BookMagazine
-    var bookMagazine = await _context.BooksMagazines.FindAsync(bookMagazineId);
-    bookMagazine.AverageRating = averageRating;
-    _context.BooksMagazines.Update(bookMagazine);
-    await _context.SaveChangesAsync();
-
-    return Ok(new { Message = "Note soumise avec succès", AverageRating = averageRating });
-}
-```
-
-#### Récupérer les notes
-
-```csharp
-[HttpGet("{id}/ratings")]
-public async Task<IActionResult> GetRatings(int id)
-{
-    var ratings = await _context.Ratings
-        .Where(r => r.BookMagazineId == id)
-        .Select(r => new {
-            r.UserId,
-            r.RatingValue,
-            r.RatingDate
-        })
-        .ToListAsync();
-
-    var averageRating = ratings.Any() ? ratings.Average(r => r.RatingValue) : 0;
-
-    return Ok(new { Ratings = ratings, AverageRating = averageRating });
-}
-```
-
-## Étape 5 : Ajout des fonctionnalités de commentaires
-
-### 5.1 Création des routes d'API pour les commentaires
-
-Nous allons permettre aux utilisateurs d'ajouter des commentaires et de répondre à des commentaires existants.
-
-**Toujours dans `BookMagazineController.cs`, ajoutez les méthodes suivantes :**
-
-#### Ajouter un commentaire
-
-```csharp
-[HttpPost("{bookMagazineId}/comment")]
-[Authorize]
-public async Task<IActionResult> AddComment(int bookMagazineId, [FromBody] string content)
-{
-    var userId = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
-
-    if (string.IsNullOrWhiteSpace(content))
-        return BadRequest("Le contenu du commentaire ne peut pas être vide.");
-
-    var comment = new Comment
-    {
-        BookMagazineId = bookMagazineId,
-        UserId = userId,
-        Content = content
-    };
-
-    _context.Comments.Add(comment);
-    await _context.SaveChangesAsync();
-
-    return Ok(new { Message = "Commentaire ajouté avec succès" });
-}
-```
-
-#### Répondre à un commentaire
-
-```csharp
-[HttpPost("{bookMagazineId}/comment/{commentId}/reply")]
-[Authorize]
-public async Task<IActionResult> ReplyToComment(int bookMagazineId, int commentId, [FromBody] string content)
-{
-    var userId = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
-
-    if (string.IsNullOrWhiteSpace(content))
-        return BadRequest("Le contenu de la réponse ne peut pas être vide.");
-
-    // Vérifier si le commentaire parent existe
-    var parentComment = await _context.Comments.FindAsync(commentId);
-    if (parentComment == null)
-        return NotFound("Le commentaire auquel vous essayez de répondre n'existe pas.");
-
-    var reply = new Comment
-    {
-        BookMagazineId = bookMagazineId,
-        UserId = userId,
-        Content = content,
-        ParentCommentId = commentId
-    };
-
-    _context.Comments.Add(reply);
-    await _context.SaveChangesAsync();
-
-    return Ok(new { Message = "Réponse ajoutée avec succès" });
-}
-```
-
-#### Récupérer les commentaires
-
-```csharp
-[HttpGet("{bookMagazineId}/comments")]
-public async Task<IActionResult> GetComments(int bookMagazineId)
-{
-    var comments = await _context.Comments
-        .Where(c => c.BookMagazineId == bookMagazineId && c.ParentCommentId == null)
-        .OrderByDescending(c => c.CommentDate)
-        .Select(c => new {
-            c.Id,
-            c.Content,
-            c.CommentDate,
-            c.UserId,
-            Replies = _context.Comments
-                .Where(r => r.ParentCommentId == c.Id)
-                .OrderBy(r => r.CommentDate)
-                .Select(r => new {
-                    r.Id,
-                    r.Content,
-                    r.CommentDate,
-                    r.UserId
-                })
-                .ToList()
-        })
-        .ToListAsync();
-
-    return Ok(comments);
-}
-```
-
-## Étape 6 : Tests et validations
-
-### 6.1 Vérifier les permissions
-
-Assurez-vous que seules les personnes authentifiées peuvent soumettre des notes et des commentaires. L'attribut `[Authorize]` dans les méthodes du contrôleur s'en charge.
-
-### 6.2 Tester les routes d'API
-
-Utilisez un outil comme **Postman** ou **Swagger** pour tester les routes :
-
-- **Soumettre une note :**
-
-  - Méthode : POST
-  - URL : `/api/BookMagazine/{bookMagazineId}/rate`
-  - Corps de la requête : un entier entre 1 et 5
-
-- **Ajouter un commentaire :**
-
-  - Méthode : POST
-  - URL : `/api/BookMagazine/{bookMagazineId}/comment`
-  - Corps de la requête : une chaîne de caractères (le contenu du commentaire)
-
-- **Répondre à un commentaire :**
-
-  - Méthode : POST
-  - URL : `/api/BookMagazine/{bookMagazineId}/comment/{commentId}/reply`
-  - Corps de la requête : une chaîne de caractères (le contenu de la réponse)
-
-- **Récupérer les notes :**
-
-  - Méthode : GET
-  - URL : `/api/BookMagazine/{id}/ratings`
-
-- **Récupérer les commentaires :**
-
-  - Méthode : GET
-  - URL : `/api/BookMagazine/{bookMagazineId}/comments`
-
-### 6.3 Vérifier le recalcul de la note moyenne
-
-Après avoir soumis plusieurs notes pour un livre ou magazine, vérifiez que la note moyenne est correctement mise à jour dans la propriété `AverageRating` du modèle `BookMagazine`.
-
-## Étape 7 : Améliorations potentielles
-
-- **Pagination des commentaires :** Si un livre ou magazine reçoit de nombreux commentaires, il peut être utile d'implémenter la pagination pour améliorer les performances.
-- **Modération :** Ajouter des fonctionnalités pour que les administrateurs puissent supprimer des commentaires inappropriés.
-- **Notifications :** Notifier les utilisateurs lorsque quelqu'un répond à leur commentaire.
-- **Votes sur les commentaires :** Permettre aux utilisateurs de voter pour les commentaires, mettant en avant les plus utiles.
-
-## Conclusion
-
-Vous avez maintenant ajouté avec succès les fonctionnalités de notes et commentaires à votre API REST .NET. Ces ajouts permettent d'améliorer l'interaction des utilisateurs avec le contenu et favorisent une communauté active autour des livres et magazines proposés.
diff --git a/docs/Partie_06_statistiques.md b/docs/Partie_06_statistiques.md
deleted file mode 100644
index 5fb9314..0000000
--- a/docs/Partie_06_statistiques.md
+++ /dev/null
@@ -1,235 +0,0 @@
- 
-
-## Tutoriel pour la Partie 6 - Statistiques et rapports
-
-Dans cette section, nous allons :
-
-1. Suivre les téléchargements de chaque livre ou magazine.
-2. Collecter des statistiques d’utilisation.
-3. Générer des rapports d’activité pour obtenir des insights sur les contenus populaires et l’engagement des utilisateurs.
-
-### Étapes pour implémenter les statistiques et rapports
-
-### 1. **Ajout de champs pour les statistiques dans le modèle `BookMagazine`**
-
-Nous allons d’abord mettre à jour le modèle `BookMagazine` pour ajouter des compteurs de vues (`ViewCount`) et de téléchargements (`DownloadCount`). Ces compteurs enregistrent les actions des utilisateurs pour chaque contenu.
-
-#### Mise à jour du modèle `BookMagazine`
-
-```csharp
-public class BookMagazine
-{
-    // Propriétés existantes
-    public int Id { get; set; }
-    public string Title { get; set; }
-    public string Description { get; set; }
-
-    // Nouvelles propriétés pour les statistiques
-    public int DownloadCount { get; set; }  // Suivi des téléchargements
-    public int ViewCount { get; set; }      // Suivi des vues
-}
-```
-
-Ensuite, appliquez cette modification dans la base de données :
-
-```bash
-dotnet ef migrations add AddViewAndDownloadCountToBookMagazine
-dotnet ef database update
-```
-
-### 2. **Incrémentation du compteur de téléchargements**
-
-Mettez à jour la méthode `DownloadBookMagazine` pour incrémenter `DownloadCount` chaque fois qu’un utilisateur télécharge un livre ou un magazine.
-
-#### Code pour incrémenter `DownloadCount`
-
-```csharp
-[HttpGet("download/{id}")]
-public async Task<IActionResult> DownloadBookMagazine(int id)
-{
-    var bookMagazine = await _context.BooksMagazines.FindAsync(id);
-    if (bookMagazine == null)
-        return NotFound();
-
-    // Incrémenter le compteur de téléchargements
-    bookMagazine.DownloadCount++;
-    _context.BooksMagazines.Update(bookMagazine);
-    await _context.SaveChangesAsync();
-
-    // Code pour gérer le téléchargement du fichier
-    var filePath = Path.Combine(Directory.GetCurrentDirectory(), "wwwroot", bookMagazine.FilePath.TrimStart('/'));
-    if (!System.IO.File.Exists(filePath))
-        return NotFound("File not found on server.");
-
-    var fileBytes = System.IO.File.ReadAllBytes(filePath);
-    var fileName = Path.GetFileName(filePath);
-
-    return File(fileBytes, "application/octet-stream", fileName);
-}
-```
-
-### 3. **Récupération des statistiques d’utilisation d’un livre ou magazine**
-
-Ajoutez une route API pour afficher les statistiques d’un livre ou magazine spécifique, notamment le nombre de vues, le nombre de téléchargements, la moyenne des notes, et le nombre de commentaires.
-
-#### Code pour la méthode `GetBookMagazineStats`
-
-```csharp
-[HttpGet("{id}/stats")]
-public IActionResult GetBookMagazineStats(int id)
-{
-    var bookMagazine = _context.BooksMagazines
-        .Where(b => b.Id == id)
-        .Select(b => new {
-            b.Title,
-            b.ViewCount,
-            b.DownloadCount,
-            AverageRating = _context.Ratings
-                .Where(r => r.BookMagazineId == id)
-                .Average(r => (double?)r.RatingValue) ?? 0,
-            CommentCount = _context.Comments.Count(c => c.BookMagazineId == id)
-        })
-        .FirstOrDefault();
-
-    if (bookMagazine == null)
-        return NotFound();
-
-    return Ok(bookMagazine);
-}
-```
-
-Cette méthode renvoie un objet contenant les statistiques d’utilisation du contenu, ce qui permet de visualiser l’engagement utilisateur.
-
-### 4. **Création de rapports sur les contenus populaires**
-
-Ajoutez une route API pour générer un rapport des livres et magazines les plus populaires en fonction du nombre de vues et de téléchargements.
-
-#### Code pour la méthode `GetPopularBooksMagazines`
-
-```csharp
-[HttpGet("reports/popular")]
-public IActionResult GetPopularBooksMagazines()
-{
-    var popularBooksMagazines = _context.BooksMagazines
-        .OrderByDescending(b => b.ViewCount + b.DownloadCount) // Trier par popularité
-        .Select(b => new {
-            b.Title,
-            b.ViewCount,
-            b.DownloadCount,
-            AverageRating = _context.Ratings
-                .Where(r => r.BookMagazineId == b.Id)
-                .Average(r => (double?)r.RatingValue) ?? 0
-        })
-        .Take(10) // Limiter à 10 résultats
-        .ToList();
-
-    return Ok(popularBooksMagazines);
-}
-```
-
-### 5. **Génération d’un rapport d’activité utilisateur**
-
-Ajoutez une route API pour générer un rapport d’activité par utilisateur, montrant l’interaction de chaque utilisateur avec les livres et magazines.
-
-#### Code pour le rapport d’activité utilisateur `GetUserActivityReport`
-
-```csharp
-[HttpGet("reports/user-activity")]
-[Authorize(Roles = "Admin")]
-public IActionResult GetUserActivityReport()
-{
-    var userActivity = _context.Users
-        .Select(u => new {
-            u.Id,
-            u.UserName,
-            FavoriteCount = _context.UserFavorites.Count(f => f.UserId == u.Id),
-            CommentCount = _context.Comments.Count(c => c.UserId == u.Id),
-            RatingCount = _context.Ratings.Count(r => r.UserId == u.Id),
-            TotalDownloads = _context.BooksMagazines
-                .Where(b => _context.UserReadingHistory
-                    .Where(ur => ur.UserId == u.Id)
-                    .Select(ur => ur.BookMagazineId)
-                    .Contains(b.Id))
-                .Sum(b => b.DownloadCount)
-        })
-        .ToList();
-
-    return Ok(userActivity);
-}
-```
-
-### 6. **Ajouter les statistiques aux réponses de consultation des livres et magazines**
-
-Pour afficher les statistiques d’un livre ou magazine dans les réponses de consultation, modifiez la méthode de consultation pour inclure les compteurs de vues, de téléchargements, et la note moyenne.
-
-#### Exemple de réponse avec statistiques pour `GetBookMagazine`
-
-```csharp
-[HttpGet("{id}")]
-public async Task<IActionResult> GetBookMagazine(int id)
-{
-    var bookMagazine = await _context.BooksMagazines
-        .Include(b => b.Author)       // Inclure l'entité 'Author'
-        .Include(b => b.Category)     // Inclure l'entité 'Category'
-        .FirstOrDefaultAsync(b => b.Id == id);
-
-    if (bookMagazine == null)
-        return NotFound();
-
-    // Vérifier que l'entité 'Author' et 'Category' ne sont pas nulles
-    if (bookMagazine.Author == null || bookMagazine.Category == null)
-        return StatusCode(500, "Invalid data: Author or Category not found.");  // Gérer les cas de données incorrectes
-
-    // Incrémenter le compteur de vues
-    bookMagazine.ViewCount++;
-    _context.BooksMagazines.Update(bookMagazine);
-    await _context.SaveChangesAsync();
-
-    // Calculer la note moyenne et le nombre de commentaires
-    var averageRating = await _context.Ratings
-        .Where(r => r.BookMagazineId == id)
-        .AverageAsync(r => (double?)r.RatingValue) ?? 0;
-
-    var commentCount = await _context.Comments
-        .CountAsync(c => c.BookMagazineId == id);
-
-    return Ok(new {
-        bookMagazine.Id,
-        bookMagazine.Title,
-        bookMagazine.Description,
-        Author = bookMagazine.Author.Name,
-        Category = bookMagazine.Category.Name,
-        bookMagazine.Tags,
-        bookMagazine.CoverImagePath,
-        bookMagazine.FilePath,
-        bookMagazine.UploadDate,
-        bookMagazine.ViewCount,      // Renvoyer le nombre de vues
-        bookMagazine.DownloadCount,   // Renvoyer le nombre de téléchargements
-        AverageRating = averageRating,  // Renvoyer la note moyenne
-        CommentCount = commentCount     // Renvoyer le nombre de commentaires
-    });
-}
-
-```
-
-### 7. **Tester les fonctionnalités de statistiques et de rapports**
-
-#### Suivi des téléchargements
-   - **Route :** `GET /api/BookMagazine/download/{id}`
-   - **Objectif :** Télécharger un livre ou magazine, et vérifier que le `DownloadCount` s’incrémente à chaque téléchargement.
-
-#### Récupération des statistiques d’un livre ou magazine
-   - **Route :** `GET /api/BookMagazine/{id}/stats`
-   - **Objectif :** Récupérer les statistiques de vues, téléchargements, notes, et commentaires pour un livre spécifique.
-
-#### Contenus populaires
-   - **Route :** `GET /api/BookMagazine/reports/popular`
-   - **Objectif :** Obtenir les 10 livres ou magazines les plus populaires (en fonction des vues et des téléchargements).
-
-#### Rapport d’activité utilisateur
-   - **Route :** `GET /api/BookMagazine/reports/user-activity`
-   - **Objectif :** Voir le rapport d’activité pour chaque utilisateur, incluant le nombre de favoris, commentaires, notes, et téléchargements.
-
----
-
-En suivant ces étapes, nous avons maintenant mis en place une solution de **suivi des téléchargements**, **statistiques d’utilisation**, et **rapports d’activité** pour l'API, offrant une vue d'ensemble de l’engagement des utilisateurs et des contenus populaires. Ces informations peuvent ensuite être utilisées pour des décisions stratégiques, améliorer l’expérience utilisateur, et adapter les contenus.
diff --git a/docs/Partie_07_notifications.md b/docs/Partie_07_notifications.md
deleted file mode 100644
index 524d61c..0000000
--- a/docs/Partie_07_notifications.md
+++ /dev/null
@@ -1,251 +0,0 @@
- 
-## Partie 7 - Notifications : Tutoriel d'Implémentation
-
-### Objectif
-
-L'objectif de cette partie est de notifier les utilisateurs par email lorsqu'il y a une nouvelle publication, une mise à jour de contenu, ou un commentaire reçu sur une ressource.
-
-### Étapes de l’implémentation
-
-### 1. Création des Modèles de Données pour les Notifications
-
-#### Modèle `Notification.cs`
-
-Ce modèle représente une notification dans le système, stockant le contenu de la notification, la date de création, et son statut (lue ou non).
-
-```csharp
-using System;
-using System.ComponentModel.DataAnnotations;
-
-public class Notification
-{
-    [Key]
-    public int Id { get; set; }
-
-    [Required]
-    public string Content { get; set; } // Message de la notification
-
-    public DateTime CreatedAt { get; set; } = DateTime.Now; // Date de création
-
-    public bool IsRead { get; set; } = false; // Indicateur si la notification est lue
-}
-```
-
-#### Modèle `UserNotification.cs`
-
-Ce modèle gère l'association entre une notification et un utilisateur, en gardant un état de notification envoyé ou non.
-
-```csharp
-using System.ComponentModel.DataAnnotations;
-
-public class UserNotification
-{
-    [Key]
-    public int Id { get; set; }
-
-    [Required]
-    public string UserId { get; set; } // ID de l'utilisateur
-
-    [Required]
-    public int NotificationId { get; set; } // ID de la notification
-
-    public Notification Notification { get; set; } // Relation avec Notification
-
-    public bool IsSent { get; set; } = false; // Indicateur si la notification est envoyée
-}
-```
-
-### 2. Mise à jour du Contexte de Base de Données
-
-Ajoutez les nouveaux modèles dans `ApplicationDbContext` pour qu’ils soient pris en charge dans la base de données.
-
-```csharp
-using Microsoft.AspNetCore.Identity.EntityFrameworkCore;
-using Microsoft.EntityFrameworkCore;
-
-public class ApplicationDbContext : IdentityDbContext<ApplicationUser>
-{
-    public ApplicationDbContext(DbContextOptions<ApplicationDbContext> options) : base(options) { }
-
-    public DbSet<Notification> Notifications { get; set; }
-    public DbSet<UserNotification> UserNotifications { get; set; }
-}
-```
-
-### 3. Ajout de la Migration et Mise à Jour de la Base de Données
-
-Créez une migration pour ajouter ces modèles à la base de données.
-
-```bash
-dotnet ef migrations add AddNotifications
-dotnet ef database update
-```
-
-### 4. Configuration du Service d’Email
-
-Pour envoyer des notifications par email, nous allons configurer un service d’envoi d’emails via SMTP.
-
-#### Ajouter la Configuration SMTP dans `appsettings.json`
-
-```json
-"EmailSettings": {
-    "SmtpServer": "smtp.example.com",
-    "Port": 587,
-    "SenderName": "Notifications MyApp",
-    "SenderEmail": "no-reply@myapp.com",
-    "Username": "smtp_username",
-    "Password": "smtp_password"
-}
-```
-
-#### Création de `EmailService.cs`
-
-Ce service utilise les paramètres SMTP pour envoyer des emails.
-
-```csharp
-using System.Net;
-using System.Net.Mail;
-using Microsoft.Extensions.Configuration;
-
-public class EmailService
-{
-    private readonly IConfiguration _configuration;
-
-    public EmailService(IConfiguration configuration)
-    {
-        _configuration = configuration;
-    }
-
-    public async Task SendEmailAsync(string toEmail, string subject, string body)
-    {
-        var smtpClient = new SmtpClient(_configuration["EmailSettings:SmtpServer"])
-        {
-            Port = int.Parse(_configuration["EmailSettings:Port"]),
-            Credentials = new NetworkCredential(
-                _configuration["EmailSettings:Username"],
-                _configuration["EmailSettings:Password"]
-            ),
-            EnableSsl = true,
-        };
-
-        var mailMessage = new MailMessage
-        {
-            From = new MailAddress(_configuration["EmailSettings:SenderEmail"], _configuration["EmailSettings:SenderName"]),
-            Subject = subject,
-            Body = body,
-            IsBodyHtml = true,
-        };
-
-        mailMessage.To.Add(toEmail);
-
-        await smtpClient.SendMailAsync(mailMessage);
-    }
-}
-```
-
-### 5. Création des Routes d’API pour les Notifications
-
-#### `NotificationController.cs`
-
-Ce contrôleur permet de créer des notifications, de les envoyer par email et de les marquer comme lues.
-
-```csharp
-using Microsoft.AspNetCore.Authorization;
-using Microsoft.AspNetCore.Mvc;
-using System.Linq;
-using System.Threading.Tasks;
-
-[ApiController]
-[Route("api/[controller]")]
-public class NotificationController : ControllerBase
-{
-    private readonly ApplicationDbContext _context;
-    private readonly EmailService _emailService;
-
-    public NotificationController(ApplicationDbContext context, EmailService emailService)
-    {
-        _context = context;
-        _emailService = emailService;
-    }
-
-    // *** Créer une notification ***
-    [HttpPost("create")]
-    [Authorize(Roles = "Admin")]
-    public async Task<IActionResult> CreateNotification([FromBody] string content)
-    {
-        var notification = new Notification { Content = content };
-        _context.Notifications.Add(notification);
-        await _context.SaveChangesAsync();
-
-        // Associer la notification à tous les utilisateurs
-        var users = _context.Users.Select(u => u.Id).ToList();
-        foreach (var userId in users)
-        {
-            _context.UserNotifications.Add(new UserNotification
-            {
-                UserId = userId,
-                NotificationId = notification.Id
-            });
-        }
-
-        await _context.SaveChangesAsync();
-
-        return Ok("Notification created successfully.");
-    }
-
-    // *** Envoyer des notifications par email ***
-    [HttpPost("send-emails")]
-    [Authorize(Roles = "Admin")]
-    public async Task<IActionResult> SendEmails()
-    {
-        var pendingNotifications = _context.UserNotifications
-            .Where(un => !un.IsSent)
-            .ToList();
-
-        foreach (var userNotification in pendingNotifications)
-        {
-            var user = _context.Users.FirstOrDefault(u => u.Id == userNotification.UserId);
-            if (user != null)
-            {
-                var notification = _context.Notifications.FirstOrDefault(n => n.Id == userNotification.NotificationId);
-                if (notification != null)
-                {
-                    await _emailService.SendEmailAsync(user.Email, "New Notification", notification.Content);
-                    userNotification.IsSent = true;
-                }
-            }
-        }
-
-        await _context.SaveChangesAsync();
-        return Ok("Emails sent successfully.");
-    }
-
-    // *** Marquer une notification comme lue ***
-    [HttpPost("mark-as-read/{notificationId}")]
-    [Authorize]
-    public async Task<IActionResult> MarkAsRead(int notificationId)
-    {
-        var userId = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
-        var userNotification = await _context.UserNotifications
-            .FirstOrDefaultAsync(un => un.NotificationId == notificationId && un.UserId == userId);
-
-        if (userNotification == null)
-            return NotFound("Notification not found for this user.");
-
-        userNotification.Notification.IsRead = true;
-        await _context.SaveChangesAsync();
-
-        return Ok("Notification marked as read.");
-    }
-}
-```
-
-### 6. Tests des Fonctions de Notifications
-
-Voici comment tester ces fonctionnalités :
-
-1. **Créer une notification** en appelant `POST /api/Notification/create` et en envoyant le message de la notification.
-2. **Envoyer les notifications par email** en appelant `POST /api/Notification/send-emails`. Cela enverra un email à chaque utilisateur associé à la notification.
-3. **Marquer la notification comme lue** en appelant `POST /api/Notification/mark-as-read/{notificationId}`.
-
-
diff --git a/docs/Partie_08_API_publique.md b/docs/Partie_08_API_publique.md
deleted file mode 100644
index 1894861..0000000
--- a/docs/Partie_08_API_publique.md
+++ /dev/null
@@ -1,133 +0,0 @@
-
-## Tutoriel : Mise en Place de l’API Publique
-
-### 1. **Configuration des Politiques CORS pour les Endpoints Publics**
-
-CORS (Cross-Origin Resource Sharing) vous permet de contrôler les sites autorisés à effectuer des requêtes vers votre API. Dans cette étape, nous ajoutons une politique CORS spécifique pour les routes publiques.
-
-1. **Ouvrez le fichier `Program.cs`.**
-
-2. **Ajoutez la configuration CORS** dans la section des services pour définir une politique qui autorise l’accès depuis une URL spécifique :
-
-   ```csharp
-   builder.Services.AddCors(options =>
-   {
-       options.AddPolicy("PublicApiPolicy", builder =>
-       {
-           builder.WithOrigins("https://trustedwebsite.com")  // Remplacez par les domaines que vous souhaitez autoriser
-                  .AllowAnyHeader()
-                  .AllowAnyMethod();
-       });
-   });
-   ```
-
-3. **Activez la politique CORS** en l’ajoutant dans le pipeline de requêtes de l'application, juste avant `app.UseAuthentication()` et `app.UseAuthorization()` :
-
-   ```csharp
-   app.UseCors("PublicApiPolicy");
-   ```
-
-Cela garantit que seuls les sites spécifiés auront accès à vos endpoints publics.
-
----
-
-### 2. **Création des Endpoints Publics**
-
-Dans cette section, nous ajoutons des routes accessibles sans authentification. Par exemple, pour exposer des statistiques sur les téléchargements ou l'utilisation de contenus.
-
-#### Exemple : **Endpoint Public pour les Statistiques de Téléchargement**
-
-1. **Ouvrez le contrôleur concerné**, par exemple `BookMagazineController`.
-
-2. **Ajoutez une route publique** pour récupérer des statistiques sans authentification. Dans cet exemple, nous créons un endpoint qui renvoie la liste des livres ou magazines les plus téléchargés :
-
-   ```csharp
-   [HttpGet("public/popular-downloads")]
-   [AllowAnonymous]  // Rendre l'endpoint public
-   public IActionResult GetPopularDownloads()
-   {
-       var popularDownloads = _context.BooksMagazines
-           .OrderByDescending(b => b.DownloadCount)
-           .Select(b => new
-           {
-               b.Id,
-               b.Title,
-               b.Author.Name,
-               b.DownloadCount
-           })
-           .ToList();
-
-       return Ok(popularDownloads);
-   }
-   ```
-
-   - **Explication** :
-     - La route `/public/popular-downloads` est marquée avec `[AllowAnonymous]`, ce qui permet un accès sans authentification.
-     - La méthode récupère les livres ou magazines les plus téléchargés et retourne des informations de base sur chacun.
-
-#### Exemple : **Endpoint Public pour Obtenir les Détails d'un Livre ou Magazine**
-
-Pour exposer les informations de base sur un livre ou magazine, ajoutez un autre endpoint :
-
-```csharp
-[HttpGet("public/book-details/{id}")]
-[AllowAnonymous]
-public async Task<IActionResult> GetBookDetails(int id)
-{
-    var bookMagazine = await _context.BooksMagazines
-        .Where(b => b.Id == id)
-        .Select(b => new
-        {
-            b.Id,
-            b.Title,
-            b.Description,
-            Author = b.Author.Name,
-            b.ViewCount,
-            b.DownloadCount
-        })
-        .FirstOrDefaultAsync();
-
-    if (bookMagazine == null)
-        return NotFound();
-
-    return Ok(bookMagazine);
-}
-```
-
-   - **Explication** :
-     - La route `/public/book-details/{id}` permet d’obtenir des informations sur un livre ou magazine spécifique en utilisant son `id`.
-     - La méthode retourne les informations de base pour permettre aux utilisateurs de consulter des informations limitées.
-
----
-
-### 3. **Documentation des Endpoints Publics avec Swagger**
-
-1. **Ouvrez `Program.cs`** et vérifiez que Swagger est configuré pour documenter les routes publiques.
-
-   Dans la configuration Swagger, ces routes seront ajoutées automatiquement. Pour vérifier et tester les routes publiques :
-
-   ```csharp
-   // Si Swagger n'est activé qu'en développement, accédez à http://localhost:{port}/swagger pour explorer les endpoints
-   if (app.Environment.IsDevelopment())
-   {
-       app.UseSwagger();
-       app.UseSwaggerUI(c =>
-       {
-           c.SwaggerEndpoint("/swagger/v1/swagger.json", "LibraryApi v1");
-       });
-   }
-   ```
-
-2. **Accédez à l’interface Swagger** pour vérifier la documentation des endpoints publics.
-
----
-
-### 4. **Tests des Endpoints Publics**
-
-1. **Depuis un navigateur ou un client API** comme Postman ou Curl, effectuez des requêtes GET sur les routes publiques, par exemple :
-
-   - `/api/BookMagazine/public/popular-downloads`
-   - `/api/BookMagazine/public/book-details/{id}`
-
-2. **Vérifiez les restrictions CORS** en accédant à ces endpoints depuis le domaine autorisé dans la configuration CORS. Testez également un domaine non autorisé pour confirmer la restriction.
-
diff --git a/docs/Partie_09_Gestion_des_fichiers.md b/docs/Partie_09_Gestion_des_fichiers.md
deleted file mode 100644
index ebf025d..0000000
--- a/docs/Partie_09_Gestion_des_fichiers.md
+++ /dev/null
@@ -1,502 +0,0 @@
- **partie 9 - Gestion des fichiers avec Amazon S3**
-
-### Prérequis
-
-1. **Compte AWS** : Créez un compte AWS si vous n'en avez pas.
-2. **Bucket S3** : Connectez-vous à votre compte AWS, accédez à S3, puis créez un bucket pour stocker les fichiers.
-3. **Clés d'accès** : Dans AWS IAM, créez un utilisateur ayant accès à S3 et téléchargez les clés d’accès et secret.
-
-### Étapes
-
----
-
-## 1. **Installer les packages AWS SDK**
-
-Pour interagir avec S3, installez le package NuGet `AWSSDK.S3` dans votre projet.
-
-```bash
-dotnet add package AWSSDK.S3
-```
-
----
-
-## 2. **Configurer l’accès AWS dans l’application**
-
-Ajoutez les informations de configuration S3 dans `appsettings.json` pour stocker les informations de connexion.
-
-```json
-"AWS": {
-    "BucketName": "your-s3-bucket-name",
-    "AccessKey": "your-access-key",
-    "SecretKey": "your-secret-key",
-    "Region": "us-east-1"
-}
-```
-
----
-
-## 3. **Configurer l’API pour AWS S3 dans `Program.cs`**
-
-Modifiez `Program.cs` pour ajouter le service S3. Cela permettra l’injection de dépendance d’AmazonS3Client dans vos contrôleurs.
-
-```csharp
-using Amazon.S3;
-using Amazon;
-
-builder.Services.AddAWSService<IAmazonS3>();  // Ajout du service Amazon S3
-```
-
----
-
-## 4. **Créer le service S3 pour la gestion des fichiers**
-
-Créez un nouveau service, `S3Service.cs`, qui contiendra la logique pour télécharger, récupérer et supprimer des fichiers dans S3.
-
-### `S3Service.cs`
-
-```csharp
-using Amazon.S3;
-using Amazon.S3.Model;
-using Microsoft.Extensions.Configuration;
-using System.Threading.Tasks;
-
-public class S3Service
-{
-    private readonly IAmazonS3 _s3Client;
-    private readonly IConfiguration _configuration;
-    private readonly string _bucketName;
-
-    public S3Service(IAmazonS3 s3Client, IConfiguration configuration)
-    {
-        _s3Client = s3Client;
-        _configuration = configuration;
-        _bucketName = _configuration["AWS:BucketName"];
-    }
-
-    // Méthode pour télécharger un fichier vers S3
-    public async Task<string> UploadFileAsync(IFormFile file, string fileKey)
-    {
-        using var stream = file.OpenReadStream();
-
-        var uploadRequest = new PutObjectRequest
-        {
-            BucketName = _bucketName,
-            Key = fileKey,
-            InputStream = stream,
-            ContentType = file.ContentType,
-            AutoCloseStream = true
-        };
-
-        await _s3Client.PutObjectAsync(uploadRequest);
-
-        return $"https://{_bucketName}.s3.amazonaws.com/{fileKey}";
-    }
-
-    // Méthode pour supprimer un fichier depuis S3
-    public async Task DeleteFileAsync(string fileKey)
-    {
-        var deleteObjectRequest = new DeleteObjectRequest
-        {
-            BucketName = _bucketName,
-            Key = fileKey
-        };
-
-        await _s3Client.DeleteObjectAsync(deleteObjectRequest);
-    }
-}
-```
-
----
-
-## 5. **Modifier le contrôleur `BookMagazineController` pour utiliser S3**
-
-Dans `BookMagazineController`, modifiez les actions de téléchargement et suppression pour utiliser le service S3.
-
-### `BookMagazineController.cs`
-
-```csharp
-using Microsoft.AspNetCore.Mvc;
-using System.Threading.Tasks;
-using Microsoft.AspNetCore.Http;
-
-[ApiController]
-[Route("api/[controller]")]
-public class BookMagazineController : ControllerBase
-{
-    private readonly S3Service _s3Service;
-
-    public BookMagazineController(S3Service s3Service)
-    {
-        _s3Service = s3Service;
-    }
-
-    // Endpoint pour ajouter un nouveau livre ou magazine avec fichier dans S3
-    [HttpPost("upload")]
-    public async Task<IActionResult> UploadBookMagazine([FromForm] IFormFile file)
-    {
-        if (file == null || file.Length == 0)
-            return BadRequest("File is missing.");
-
-        var fileKey = $"{Guid.NewGuid()}_{file.FileName}"; // Nom unique pour le fichier dans S3
-        var fileUrl = await _s3Service.UploadFileAsync(file, fileKey);
-
-        // Enregistrer l’URL dans la base de données si nécessaire
-        // Ex : bookMagazine.FileUrl = fileUrl;
-
-        return Ok(new { FileUrl = fileUrl });
-    }
-
-    // Endpoint pour supprimer un livre ou magazine
-    [HttpDelete("delete/{fileKey}")]
-    public async Task<IActionResult> DeleteBookMagazine(string fileKey)
-    {
-        await _s3Service.DeleteFileAsync(fileKey);
-        return Ok("File deleted successfully.");
-    }
-}
-```
-
----
-
-## 6. **Configurer la compression des fichiers avant le téléchargement**
-
-Pour compresser les fichiers avant de les télécharger dans S3, installez un package de compression, comme `System.IO.Compression`.
-
-```bash
-dotnet add package System.IO.Compression
-```
-
-Ensuite, modifiez la méthode `UploadFileAsync` dans `S3Service` pour compresser les fichiers avant de les envoyer à S3.
-
-```csharp
-using System.IO.Compression;
-
-// Compression avant téléchargement
-public async Task<string> UploadFileAsync(IFormFile file, string fileKey)
-{
-    using var compressedStream = new MemoryStream();
-    using (var zipArchive = new ZipArchive(compressedStream, ZipArchiveMode.Create, true))
-    {
-        var zipEntry = zipArchive.CreateEntry(file.FileName, CompressionLevel.Optimal);
-        using var originalFileStream = file.OpenReadStream();
-        using var entryStream = zipEntry.Open();
-        await originalFileStream.CopyToAsync(entryStream);
-    }
-
-    compressedStream.Seek(0, SeekOrigin.Begin);  // Revenir au début du flux pour le téléchargement
-
-    var uploadRequest = new PutObjectRequest
-    {
-        BucketName = _bucketName,
-        Key = fileKey,
-        InputStream = compressedStream,
-        ContentType = "application/zip"
-    };
-
-    await _s3Client.PutObjectAsync(uploadRequest);
-    return $"https://{_bucketName}.s3.amazonaws.com/{fileKey}";
-}
-```
-
----
-
-## 7. **Ajouter une migration pour stocker les informations de fichier dans la base de données**
-
-Ajoutez un champ `FileUrl` à votre modèle `BookMagazine` pour stocker l’URL du fichier S3.
-
-### Modèle `BookMagazine.cs`
-
-```csharp
-public class BookMagazine
-{
-    public int Id { get; set; }
-    public string Title { get; set; }
-    // Autres propriétés...
-
-    public string FileUrl { get; set; } // URL du fichier dans S3
-}
-```
-
-### Créer la migration
-
-```bash
-dotnet ef migrations add AddFileUrlToBookMagazine
-dotnet ef database update
-```
-
----
-
-## 8. **Configurer le CORS pour autoriser l’accès public (si nécessaire)**
-
-Si les fichiers sont accessibles publiquement, vous devrez configurer le CORS pour autoriser les requêtes vers l’API depuis d’autres origines.
-
-### `Program.cs`
-
-```csharp
-builder.Services.AddCors(options =>
-{
-    options.AddPolicy("PublicApiPolicy", builder =>
-    {
-        builder.WithOrigins("https://trustedwebsite.com")
-               .AllowAnyHeader()
-               .AllowAnyMethod();
-    });
-});
-
-app.UseCors("PublicApiPolicy");
-```
-
----
-
-## 9. **Tester et vérifier**
-
-1. **Téléchargement de fichier** : Accédez à `POST /api/BookMagazine/upload` et téléchargez un fichier. Le service renverra l’URL du fichier dans S3.
-2. **Suppression de fichier** : Accédez à `DELETE /api/BookMagazine/delete/{fileKey}` en passant le nom du fichier. Cette action supprimera le fichier du stockage S3.
-3. **Vérifiez S3** pour voir si le fichier est bien stocké ou supprimé.
-
----
-
-
-
-
-
-**partie 9 - Gestion des fichiers avec Azure Blob Storage**
-
-### Prérequis
-
-1. **Compte Azure** : Créez un compte Azure si vous n'en avez pas encore.
-2. **Création d’un Container de stockage** : Connectez-vous au portail Azure, créez un compte de stockage (Standard, BlobStorage) et créez un conteneur (par exemple : "bookmagazines") pour stocker les fichiers.
-
-### Étapes
-
----
-
-## 1. **Installer le package Azure Storage SDK**
-
-Pour interagir avec Azure Blob Storage, installez le package `Azure.Storage.Blobs`.
-
-```bash
-dotnet add package Azure.Storage.Blobs
-```
-
----
-
-## 2. **Configurer l’accès Azure dans `appsettings.json`**
-
-Ajoutez les informations de configuration Azure Blob dans votre fichier `appsettings.json` :
-
-```json
-"AzureBlobStorage": {
-    "ConnectionString": "your-azure-blob-connection-string",
-    "ContainerName": "bookmagazines"
-}
-```
-
----
-
-## 3. **Configurer l’API pour Azure Blob Storage dans `Program.cs`**
-
-Modifiez `Program.cs` pour ajouter les services Azure Blob afin qu'ils soient injectés dans vos contrôleurs.
-
-### `Program.cs`
-
-```csharp
-using Azure.Storage.Blobs;
-
-builder.Services.AddSingleton(x => new BlobServiceClient(builder.Configuration["AzureBlobStorage:ConnectionString"]));
-builder.Services.AddScoped<BlobStorageService>(); // Ajout du service de gestion des blobs
-```
-
----
-
-## 4. **Créer le service de gestion de Blob Storage**
-
-Créez un service, `BlobStorageService.cs`, qui contiendra la logique de téléchargement, récupération, et suppression des fichiers sur Azure Blob Storage.
-
-### `BlobStorageService.cs`
-
-```csharp
-using Azure.Storage.Blobs;
-using Azure.Storage.Blobs.Models;
-using Microsoft.Extensions.Configuration;
-using System.IO;
-using System.Threading.Tasks;
-
-public class BlobStorageService
-{
-    private readonly BlobServiceClient _blobServiceClient;
-    private readonly string _containerName;
-
-    public BlobStorageService(BlobServiceClient blobServiceClient, IConfiguration configuration)
-    {
-        _blobServiceClient = blobServiceClient;
-        _containerName = configuration["AzureBlobStorage:ContainerName"];
-    }
-
-    // Méthode pour télécharger un fichier dans Azure Blob Storage
-    public async Task<string> UploadFileAsync(IFormFile file, string blobName)
-    {
-        var containerClient = _blobServiceClient.GetBlobContainerClient(_containerName);
-        await containerClient.CreateIfNotExistsAsync();
-        await containerClient.SetAccessPolicyAsync(PublicAccessType.Blob); // Pour un accès public aux fichiers si nécessaire
-
-        var blobClient = containerClient.GetBlobClient(blobName);
-        using var stream = file.OpenReadStream();
-        await blobClient.UploadAsync(stream, new BlobHttpHeaders { ContentType = file.ContentType });
-
-        return blobClient.Uri.ToString(); // Retourne l'URL du fichier
-    }
-
-    // Méthode pour supprimer un fichier depuis Azure Blob Storage
-    public async Task DeleteFileAsync(string blobName)
-    {
-        var containerClient = _blobServiceClient.GetBlobContainerClient(_containerName);
-        var blobClient = containerClient.GetBlobClient(blobName);
-        await blobClient.DeleteIfExistsAsync();
-    }
-}
-```
-
----
-
-## 5. **Modifier le contrôleur `BookMagazineController` pour utiliser Azure Blob Storage**
-
-Dans `BookMagazineController`, modifiez les actions pour télécharger et supprimer des fichiers en utilisant `BlobStorageService`.
-
-### `BookMagazineController.cs`
-
-```csharp
-using Microsoft.AspNetCore.Mvc;
-using System.Threading.Tasks;
-using Microsoft.AspNetCore.Http;
-
-[ApiController]
-[Route("api/[controller]")]
-public class BookMagazineController : ControllerBase
-{
-    private readonly BlobStorageService _blobStorageService;
-
-    public BookMagazineController(BlobStorageService blobStorageService)
-    {
-        _blobStorageService = blobStorageService;
-    }
-
-    // Endpoint pour ajouter un nouveau livre ou magazine avec un fichier dans Azure Blob Storage
-    [HttpPost("upload")]
-    public async Task<IActionResult> UploadBookMagazine([FromForm] IFormFile file)
-    {
-        if (file == null || file.Length == 0)
-            return BadRequest("File is missing.");
-
-        var blobName = $"{Guid.NewGuid()}_{file.FileName}"; // Nom unique pour le fichier dans Azure Blob
-        var fileUrl = await _blobStorageService.UploadFileAsync(file, blobName);
-
-        // Enregistrer l’URL dans la base de données si nécessaire
-        // Ex : bookMagazine.FileUrl = fileUrl;
-
-        return Ok(new { FileUrl = fileUrl });
-    }
-
-    // Endpoint pour supprimer un livre ou magazine
-    [HttpDelete("delete/{blobName}")]
-    public async Task<IActionResult> DeleteBookMagazine(string blobName)
-    {
-        await _blobStorageService.DeleteFileAsync(blobName);
-        return Ok("File deleted successfully.");
-    }
-}
-```
-
----
-
-## 6. **Ajouter une migration pour stocker l’URL du fichier dans la base de données**
-
-Ajoutez un champ `FileUrl` à votre modèle `BookMagazine` pour stocker l’URL du fichier sur Azure Blob Storage.
-
-### Modèle `BookMagazine.cs`
-
-```csharp
-public class BookMagazine
-{
-    public int Id { get; set; }
-    public string Title { get; set; }
-    // Autres propriétés...
-
-    public string FileUrl { get; set; } // URL du fichier dans Azure Blob Storage
-}
-```
-
-### Créer et appliquer la migration
-
-```bash
-dotnet ef migrations add AddFileUrlToBookMagazine
-dotnet ef database update
-```
-
----
-
-## 7. **Configurer la compression des fichiers avant le téléchargement**
-
-Pour compresser les fichiers avant de les télécharger, installez un package de compression, comme `System.IO.Compression`.
-
-```bash
-dotnet add package System.IO.Compression
-```
-
-Ensuite, modifiez la méthode `UploadFileAsync` dans `BlobStorageService` pour compresser les fichiers avant de les envoyer sur Azure Blob Storage.
-
-```csharp
-using System.IO.Compression;
-
-// Compression avant téléchargement
-public async Task<string> UploadFileAsync(IFormFile file, string blobName)
-{
-    using var compressedStream = new MemoryStream();
-    using (var zipArchive = new ZipArchive(compressedStream, ZipArchiveMode.Create, true))
-    {
-        var zipEntry = zipArchive.CreateEntry(file.FileName, CompressionLevel.Optimal);
-        using var originalFileStream = file.OpenReadStream();
-        using var entryStream = zipEntry.Open();
-        await originalFileStream.CopyToAsync(entryStream);
-    }
-
-    compressedStream.Seek(0, SeekOrigin.Begin);  // Revenir au début du flux pour le téléchargement
-
-    var containerClient = _blobServiceClient.GetBlobContainerClient(_containerName);
-    var blobClient = containerClient.GetBlobClient(blobName);
-    await blobClient.UploadAsync(compressedStream, new BlobHttpHeaders { ContentType = "application/zip" });
-
-    return blobClient.Uri.ToString();
-}
-```
-
----
-
-## 8. **Configurer le CORS pour autoriser l’accès public (si nécessaire)**
-
-Si vous souhaitez permettre l’accès aux fichiers depuis des applications externes, configurez le CORS dans le portail Azure pour votre compte de stockage ou configurez le CORS dans votre application.
-
-### `Program.cs`
-
-```csharp
-builder.Services.AddCors(options =>
-{
-    options.AddPolicy("PublicApiPolicy", builder =>
-    {
-        builder.WithOrigins("https://trustedwebsite.com")
-               .AllowAnyHeader()
-               .AllowAnyMethod();
-    });
-});
-
-app.UseCors("PublicApiPolicy");
-```
-
----
-
-## 9. **Tester et vérifier**
-
-1. **Téléchargement de fichier** : Accédez à `POST /api/BookMagazine/upload` pour tester le téléchargement d’un fichier. L'API doit renvoyer l’URL du fichier sur Azure Blob Storage.
-2. **Suppression de fichier** : Accédez à `DELETE /api/BookMagazine/delete/{blobName}` avec le nom du fichier dans Azure pour le supprimer.
-3. **Vérifiez dans Azure Blob Storage** pour confirmer que le fichier est bien stocké ou supprimé.
-
diff --git a/docs/Partie_10_securite_performance.md b/docs/Partie_10_securite_performance.md
deleted file mode 100644
index de35551..0000000
--- a/docs/Partie_10_securite_performance.md
+++ /dev/null
@@ -1,221 +0,0 @@
-
-## Partie 10 : Tutoriel de Sécurité et Performance pour l’API REST
-
-Dans cette partie, nous allons ajouter des mesures de sécurité supplémentaires et optimiser les performances de l’API.
-
-### 1. **Authentification JWT**
-
-Nous avons déjà configuré l'authentification JWT. Rappelons brièvement le fonctionnement et les composants nécessaires pour cette configuration.
-
-#### Fichier `appsettings.json`
-
-Ajoutez ou vérifiez les paramètres de configuration pour le JWT :
-
-```json
-"Jwt": {
-  "Key": "YourSecureKeyHere",
-  "Issuer": "YourIssuer",
-  "Audience": "YourAudience"
-}
-```
-
-#### Configuration dans `Program.cs`
-
-Vérifiez que l’authentification JWT est correctement configurée dans `Program.cs` :
-
-```csharp
-builder.Services.AddAuthentication(options =>
-{
-    options.DefaultAuthenticateScheme = JwtBearerDefaults.AuthenticationScheme;
-    options.DefaultChallengeScheme = JwtBearerDefaults.AuthenticationScheme;
-})
-.AddJwtBearer(options =>
-{
-    options.TokenValidationParameters = new TokenValidationParameters
-    {
-        ValidateIssuer = true,
-        ValidateAudience = true,
-        ValidateLifetime = true,
-        ValidateIssuerSigningKey = true,
-        ValidIssuer = builder.Configuration["Jwt:Issuer"],
-        ValidAudience = builder.Configuration["Jwt:Audience"],
-        IssuerSigningKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(builder.Configuration["Jwt:Key"]))
-    };
-});
-```
-
-### 2. **Protection contre les attaques courantes**
-
-#### Protection contre l'Injection SQL
-
-En utilisant Entity Framework, les paramètres sont automatiquement protégés contre l'injection SQL, car toutes les requêtes sont préparées de manière sécurisée. Il est néanmoins conseillé d’utiliser les filtres LINQ pour sécuriser les requêtes.
-
-#### Protection contre CSRF (Cross-Site Request Forgery)
-
-Dans une API REST, CSRF est moins problématique, mais si votre API est utilisée par des applications frontales, vous pouvez ajouter une vérification de l’origine des requêtes (mécanisme CORS) pour restreindre les requêtes venant de domaines spécifiques.
-
-Ajoutez cette configuration dans `Program.cs` :
-
-```csharp
-builder.Services.AddCors(options =>
-{
-    options.AddPolicy("CorsPolicy", builder =>
-    {
-        builder.WithOrigins("https://yourfrontend.com") // Remplacez par votre domaine
-               .AllowAnyHeader()
-               .AllowAnyMethod();
-    });
-});
-
-app.UseCors("CorsPolicy");
-```
-
-### 3. **Mise en Cache**
-
-Pour améliorer les performances de l'API, vous pouvez mettre en cache les réponses des endpoints les plus sollicités. La mise en cache permet de limiter les appels à la base de données pour les requêtes qui peuvent être servies avec des données qui ne changent pas fréquemment.
-
-#### a) Configuration du Service de Cache
-
-Ajoutez le service de cache en mémoire dans `Program.cs` :
-
-```csharp
-builder.Services.AddMemoryCache();
-```
-
-#### b) Mise en Cache dans les Méthodes
-
-Implémentons la mise en cache sur plusieurs méthodes comme `GetBookMagazine`, `GetBooksMagazinesList`, et `GetPopularBooksMagazines`.
-
----
-
-#### **Méthode : `GetBookMagazine` (détails d'un livre)**
-
-```csharp
-[HttpGet("{id}")]
-public async Task<IActionResult> GetBookMagazine(int id)
-{
-    if (!_cache.TryGetValue($"BookMagazine_{id}", out var bookMagazine))
-    {
-        bookMagazine = await _context.BooksMagazines
-            .Include(b => b.Author)
-            .Include(b => b.Category)
-            .Where(b => b.Id == id)
-            .Select(b => new
-            {
-                b.Id,
-                b.Title,
-                b.Description,
-                Author = b.Author.Name,
-                Category = b.Category.Name,
-                b.Tags,
-                b.CoverImagePath,
-                b.FilePath,
-                b.UploadDate,
-                b.ViewCount,
-                b.DownloadCount,
-                AverageRating = _context.Ratings
-                    .Where(r => r.BookMagazineId == id)
-                    .Average(r => (double?)r.RatingValue) ?? 0,
-                CommentCount = _context.Comments.Count(c => c.BookMagazineId == id)
-            })
-            .FirstOrDefaultAsync();
-
-        if (bookMagazine == null)
-            return NotFound();
-
-        var cacheOptions = new MemoryCacheEntryOptions
-        {
-            AbsoluteExpirationRelativeToNow = TimeSpan.FromMinutes(5)
-        };
-
-        _cache.Set($"BookMagazine_{id}", bookMagazine, cacheOptions);
-    }
-
-    return Ok(bookMagazine);
-}
-```
-
-#### **Méthode : `GetBooksMagazinesList` (liste de livres/magazines)**
-
-```csharp
-[HttpGet("list")]
-public async Task<IActionResult> GetBooksMagazinesList()
-{
-    if (!_cache.TryGetValue("BooksMagazinesList", out var booksMagazines))
-    {
-        booksMagazines = await _context.BooksMagazines
-            .Select(b => new
-            {
-                b.Id,
-                b.Title,
-                Author = b.Author.Name,
-                Category = b.Category.Name,
-                b.CoverImagePath,
-                b.UploadDate
-            })
-            .ToListAsync();
-
-        var cacheOptions = new MemoryCacheEntryOptions
-        {
-            AbsoluteExpirationRelativeToNow = TimeSpan.FromMinutes(10)
-        };
-
-        _cache.Set("BooksMagazinesList", booksMagazines, cacheOptions);
-    }
-
-    return Ok(booksMagazines);
-}
-```
-
-#### **Méthode : `GetPopularBooksMagazines` (contenus populaires)**
-
-```csharp
-[HttpGet("search/popular")]
-public async Task<IActionResult> GetPopularBooksMagazines()
-{
-    if (!_cache.TryGetValue("PopularBooksMagazines", out var popularBooksMagazines))
-    {
-        popularBooksMagazines = await _context.BooksMagazines
-            .OrderByDescending(b => b.ViewCount)
-            .Select(b => new
-            {
-                b.Id,
-                b.Title,
-                Author = b.Author.Name,
-                b.CoverImagePath,
-                b.UploadDate,
-                b.ViewCount
-            })
-            .ToListAsync();
-
-        var cacheOptions = new MemoryCacheEntryOptions
-        {
-            AbsoluteExpirationRelativeToNow = TimeSpan.FromMinutes(15)
-        };
-
-        _cache.Set("PopularBooksMagazines", popularBooksMagazines, cacheOptions);
-    }
-
-    return Ok(popularBooksMagazines);
-}
-```
-
-### 4. **Résumé des Étapes de Test**
-
-Une fois la configuration en place, voici comment tester les fonctionnalités ajoutées :
-
-1. **Tester l'authentification JWT** : Assurez-vous que l'authentification est bien en place et que seuls les utilisateurs authentifiés peuvent accéder aux endpoints protégés.
-2. **Vérifier les protections contre les attaques courantes** : Utilisez des outils comme OWASP ZAP pour vérifier les failles potentielles (injections, CSRF, etc.).
-3. **Test de la mise en cache** :
-   - Faites plusieurs appels à un endpoint mis en cache (par exemple, `GetBookMagazine`) et vérifiez que les requêtes suivantes sont plus rapides.
-   - Testez l'invalidation et la mise à jour du cache en effectuant des modifications (ex. : ajout d'un commentaire) et en observant les mises à jour.
-
-
-### Conclusion
-
-En suivant ce tutoriel, vous avez maintenant amélioré la sécurité et optimisé les performances de l’API avec :
-- **L’authentification JWT** pour sécuriser les endpoints.
-- **La protection contre les attaques courantes** avec des filtres, des configurations CORS, et des vérifications de l’entrée.
-- **La mise en cache** sur plusieurs endpoints stratégiques pour réduire la charge de la base de données et améliorer la rapidité de réponse de l’API.
-
-Cela contribuera à rendre votre application plus robuste, sécurisée et performante.
diff --git a/docs/introduction.md b/docs/introduction.md
deleted file mode 100644
index c129234..0000000
--- a/docs/introduction.md
+++ /dev/null
@@ -1,50 +0,0 @@
- 
-
-Pour un projet d'API REST .NET permettant aux utilisateurs de stocker, consulter, télécharger des livres ou des magazines, quelques idées de fonctionnalités :
-
-### 1. **Gestion des utilisateurs :**
-   - **Inscription et connexion** : Permettre aux utilisateurs de créer un compte, se connecter et se déconnecter.
-   - **Gestion des profils** : Les utilisateurs peuvent mettre à jour leurs informations (nom, email, photo de profil, etc.).
-   - **Rôles et autorisations** : Implémenter différents rôles (ex. administrateur, utilisateur standard) avec des permissions spécifiques.
-
-### 2. **Gestion des livres et magazines :**
-   - **Ajout de contenu** : Permettre aux utilisateurs d'ajouter des livres ou des magazines (titre, auteur, description, catégorie, fichier PDF ou EPUB, etc.).
-   - **Consultation du contenu** : Les utilisateurs peuvent rechercher et consulter les détails des livres ou magazines disponibles.
-   - **Téléchargement** : Option de télécharger le fichier du livre ou du magazine en différents formats (PDF, EPUB).
-   - **Catégories et tags** : Organisation des contenus par catégories ou tags pour faciliter la recherche.
-
-### 3. **Bibliothèque personnelle :**
-   - **Favoris** : Les utilisateurs peuvent ajouter des livres ou magazines à leur liste de favoris pour un accès rapide.
-   - **Historique de lecture** : Garder une trace des livres ou magazines que l'utilisateur a consultés ou lus.
-
-### 4. **Recherche et filtres avancés :**
-   - **Recherche par mots-clés** : Recherche rapide par titre, auteur, ou description.
-   - **Filtres** : Filtres par catégories, date de publication, auteur, popularité, etc.
-   - **Suggestions** : Système de recommandations basé sur les lectures passées ou les intérêts de l'utilisateur.
-
-### 5. **Notes et commentaires :**
-   - **Évaluation des livres/magazines** : Les utilisateurs peuvent noter les livres ou magazines.
-   - **Commentaires** : Fonctionnalité de commentaires pour partager des avis ou discuter autour d'un livre ou d'un magazine.
-   - **Réponses aux commentaires** : Possibilité de répondre aux commentaires pour initier des discussions.
-
-### 6. **Statistiques et rapports :**
-   - **Suivi des téléchargements** : Suivi du nombre de téléchargements pour chaque livre ou magazine.
-   - **Statistiques d’utilisation** : Statistiques sur les lectures, les téléchargements, etc.
-   - **Rapports d’activité** : Générer des rapports sur l’activité des utilisateurs, les contenus populaires, etc.
-
-### 7. **Notifications :**
-   - **Notifications par email ou push** : Notifications sur les nouvelles publications, mises à jour de contenus, commentaires reçus, etc.
-
-### 8. **API publique :**
-   - **Endpoints publics** : Certains contenus ou statistiques peuvent être rendus disponibles via des endpoints publics pour être intégrés dans d'autres applications ou sites.
-
-### 9. **Gestion des fichiers :**
-   - **Stockage dans le cloud** : Intégration avec un service de stockage cloud (comme AWS S3, Azure Blob Storage) pour stocker les fichiers des livres et magazines.
-   - **Compression et optimisation** : Compression des fichiers téléchargés pour optimiser l'espace de stockage.
-
-### 10. **Sécurité et performance :**
-   - **Authentification JWT** : Utilisation de JSON Web Tokens (JWT) pour sécuriser l’API.
-   - **Protection contre les attaques courantes** : Implémentation de mesures de sécurité contre les attaques courantes (ex. : SQL Injection, CSRF).
-   - **Mise en cache** : Implémenter la mise en cache pour améliorer les performances des endpoints les plus sollicités.
-
-Avec ces fonctionnalités, l'API pourrait offrir une expérience complète, tout en étant flexible et extensible pour de futures évolutions.
diff --git a/src/Controllers/Admin/AuditController.cs b/src/Controllers/Admin/AuditController.cs
index 092bcf2..812be79 100644
--- a/src/Controllers/Admin/AuditController.cs
+++ b/src/Controllers/Admin/AuditController.cs
@@ -1,8 +1,12 @@
-// Controllers/Admin/AuditController.cs
+// Controllers/Admin/AuditController.cs - Version étendue
 using Microsoft.AspNetCore.Authorization;
 using Microsoft.AspNetCore.Mvc;
 using Microsoft.EntityFrameworkCore;
 using LibraryAPI.Data;
+using LibraryAPI.Models;
+using LibraryAPI.Models.DTOs;
+using LibraryAPI.Services;
+using System.Diagnostics;
 
 namespace LibraryAPI.Controllers.Admin
 {
@@ -12,67 +16,1015 @@ namespace LibraryAPI.Controllers.Admin
     public class AuditController : ControllerBase
     {
         private readonly ApplicationDbContext _context;
+        private readonly ILogger<AuditController> _logger;
+        private readonly AuditArchiveService _archiveService;
+        private readonly IConfiguration _configuration;
 
-        public AuditController(ApplicationDbContext context)
+        public AuditController(
+            ApplicationDbContext context,
+            ILogger<AuditController> logger,
+            AuditArchiveService archiveService,
+            IConfiguration configuration)
         {
             _context = context;
+            _logger = logger;
+            _archiveService = archiveService;
+            _configuration = configuration;
         }
 
+        /// <summary>
+        /// Récupère les logs d'audit avec pagination
+        /// </summary>
         [HttpGet("logs")]
         public async Task<IActionResult> GetLogs([FromQuery] int page = 1, [FromQuery] int size = 50)
         {
-            var logs = await _context.AuditLogs
-                .OrderByDescending(a => a.CreatedAt)
-                .Skip((page - 1) * size)
-                .Take(size)
-                .Select(a => new
-                {
-                    a.Id,
-                    a.UserId,
-                    a.Action,
-                    a.Message,
-                    a.CreatedAt,
-                    a.IpAddress
-                })
-                .ToListAsync();
-
-            return Ok(logs);
+            try
+            {
+                if (page < 1 || size < 1 || size > 200)
+                {
+                    return BadRequest("Page doit être >= 1 et size entre 1 et 200");
+                }
+
+                var totalLogs = await _context.AuditLogs.CountAsync();
+                var logs = await _context.AuditLogs
+                    .OrderByDescending(a => a.CreatedAt)
+                    .Skip((page - 1) * size)
+                    .Take(size)
+                    .Select(a => new
+                    {
+                        a.Id,
+                        a.UserId,
+                        a.Action,
+                        a.Message,
+                        a.CreatedAt,
+                        a.IpAddress
+                    })
+                    .ToListAsync();
+
+                return Ok(new
+                {
+                    Logs = logs,
+                    Pagination = new
+                    {
+                        Page = page,
+                        Size = size,
+                        TotalItems = totalLogs,
+                        TotalPages = (int)Math.Ceiling(totalLogs / (double)size)
+                    }
+                });
+            }
+            catch (Exception ex)
+            {
+                _logger.LogError(ex, "Erreur lors de la récupération des logs d'audit");
+                return StatusCode(500, "Erreur interne du serveur");
+            }
         }
 
+        /// <summary>
+        /// Obtient des statistiques détaillées sur la base de données d'audit
+        /// </summary>
+        [HttpGet("database-size")]
+        public async Task<IActionResult> GetDatabaseStats()
+        {
+            try
+            {
+                var stopwatch = Stopwatch.StartNew();
+
+                // Statistiques de base
+                var totalLogs = await _context.AuditLogs.CountAsync();
+                var last7Days = await _context.AuditLogs
+                    .CountAsync(a => a.CreatedAt >= DateTime.UtcNow.AddDays(-7));
+                var last30Days = await _context.AuditLogs
+                    .CountAsync(a => a.CreatedAt >= DateTime.UtcNow.AddDays(-30));
+
+                // Dates extrêmes
+                var oldestLog = await _context.AuditLogs
+                    .OrderBy(a => a.CreatedAt)
+                    .Select(a => a.CreatedAt)
+                    .FirstOrDefaultAsync();
+
+                var newestLog = await _context.AuditLogs
+                    .OrderByDescending(a => a.CreatedAt)
+                    .Select(a => a.CreatedAt)
+                    .FirstOrDefaultAsync();
+
+                // Top actions
+                var topActions = await _context.AuditLogs
+                    .GroupBy(a => a.Action)
+                    .Select(g => new ActionStatistic
+                    {
+                        Action = g.Key ?? "UNKNOWN",
+                        Count = g.Count(),
+                        FirstOccurrence = g.Min(x => x.CreatedAt),
+                        LastOccurrence = g.Max(x => x.CreatedAt)
+                    })
+                    .OrderByDescending(x => x.Count)
+                    .Take(10)
+                    .ToListAsync();
+
+                // Calcul des pourcentages
+                foreach (var action in topActions)
+                {
+                    action.Percentage = totalLogs > 0 ? (double)action.Count / totalLogs * 100 : 0;
+                }
+
+                // Distribution mensuelle (6 derniers mois)
+                var sixMonthsAgo = DateTime.UtcNow.AddMonths(-6);
+                var monthlyStats = await _context.AuditLogs
+                    .Where(a => a.CreatedAt >= sixMonthsAgo)
+                    .GroupBy(a => new { a.CreatedAt.Year, a.CreatedAt.Month })
+                    .Select(g => new
+                    {
+                        YearMonth = $"{g.Key.Year:0000}-{g.Key.Month:00}",
+                        Count = g.Count(),
+                        TopActions = g.GroupBy(x => x.Action)
+                                   .OrderByDescending(ag => ag.Count())
+                                   .Take(3)
+                                   .Select(ag => ag.Key ?? "UNKNOWN")
+                                   .ToList()
+                    })
+                    .OrderBy(x => x.YearMonth)
+                    .ToListAsync();
+
+                var monthlyDistribution = monthlyStats.Select(m => new MonthlyStatistic
+                {
+                    YearMonth = m.YearMonth,
+                    Count = m.Count,
+                    TopActionsThisMonth = m.TopActions
+                }).ToList();
+
+                // Estimation de taille
+                var avgMessageLength = totalLogs > 0
+                    ? await _context.AuditLogs.AverageAsync(a => (double?)a.Message!.Length) ?? 0
+                    : 0;
+
+                var estimatedSizePerLog = 50 + avgMessageLength + 20; // ID, dates, IP, etc. + message
+                var totalSizeKB = (long)(totalLogs * estimatedSizePerLog / 1024);
+
+                var dailyGrowth = last7Days > 0 ? last7Days / 7.0 : 0;
+                var dailyGrowthKB = dailyGrowth * estimatedSizePerLog / 1024;
+
+                var sizeEstimate = new DatabaseSizeEstimate
+                {
+                    EstimatedSizeKB = totalSizeKB,
+                    AverageSizePerLog = estimatedSizePerLog,
+                    DailyGrowthKB = dailyGrowthKB,
+                    Predicted30DaysKB = dailyGrowthKB * 30
+                };
+
+                stopwatch.Stop();
+
+                var stats = new AuditDatabaseStats
+                {
+                    TotalLogs = totalLogs,
+                    LogsLast7Days = last7Days,
+                    LogsLast30Days = last30Days,
+                    OldestLog = oldestLog == default ? null : oldestLog,
+                    NewestLog = newestLog == default ? null : newestLog,
+                    TopActions = topActions,
+                    MonthlyDistribution = monthlyDistribution,
+                    SizeEstimate = sizeEstimate
+                };
+
+                _logger.LogInformation("📊 Statistiques d'audit calculées en {Duration}ms", stopwatch.ElapsedMilliseconds);
+
+                return Ok(stats);
+            }
+            catch (Exception ex)
+            {
+                _logger.LogError(ex, "Erreur lors du calcul des statistiques d'audit");
+                return StatusCode(500, "Erreur lors du calcul des statistiques");
+            }
+        }
+
+        /// <summary>
+        /// Nettoyage manuel des logs d'audit
+        /// </summary>
+        [HttpPost("cleanup")]
+        public async Task<IActionResult> CleanupLogs([FromBody] CleanupRequest request)
+        {
+            try
+            {
+                var stopwatch = Stopwatch.StartNew();
+                var cutoffDate = DateTime.UtcNow.AddDays(-request.RetentionDays);
+
+                _logger.LogInformation("🧹 Début du nettoyage manuel - Rétention: {Days} jours, Cutoff: {CutoffDate}",
+                                      request.RetentionDays, cutoffDate);
+
+                List<AuditLog> logsToProcess;
+
+                // Filtrage par type d'action si spécifié
+                if (!string.IsNullOrEmpty(request.ActionType))
+                {
+                    logsToProcess = await _context.AuditLogs
+                        .Where(log => log.Action.Contains(request.ActionType) && log.CreatedAt < cutoffDate)
+                        .ToListAsync();
+                }
+                else
+                {
+                    logsToProcess = await _context.AuditLogs
+                        .Where(log => log.CreatedAt < cutoffDate)
+                        .ToListAsync();
+                }
+
+                if (!logsToProcess.Any())
+                {
+                    return Ok(new CleanupResponse
+                    {
+                        Message = "Aucun log à nettoyer selon les critères spécifiés",
+                        DeletedCount = 0,
+                        CutoffDate = cutoffDate,
+                        DurationMs = stopwatch.ElapsedMilliseconds,
+                        IsPreview = request.PreviewOnly
+                    });
+                }
+
+                // Mode preview : retourner le nombre sans supprimer
+                if (request.PreviewOnly)
+                {
+                    var previewStats = logsToProcess
+                        .GroupBy(l => l.Action)
+                        .ToDictionary(g => g.Key ?? "UNKNOWN", g => g.Count());
+
+                    return Ok(new CleanupResponse
+                    {
+                        Message = $"Aperçu : {logsToProcess.Count} logs seraient supprimés",
+                        DeletedCount = logsToProcess.Count,
+                        CutoffDate = cutoffDate,
+                        DetailedStats = previewStats,
+                        DurationMs = stopwatch.ElapsedMilliseconds,
+                        IsPreview = true
+                    });
+                }
+
+                // Archivage avant suppression si demandé
+                string? archiveFilePath = null;
+                if (request.ArchiveBeforeDelete)
+                {
+                    var actionType = request.ActionType ?? "MANUAL_CLEANUP";
+                    archiveFilePath = await _archiveService.ArchiveLogsAsync(
+                        logsToProcess, actionType, ArchiveFormat.JSON, false);
+                }
+
+                // Statistiques détaillées avant suppression
+                var detailedStats = logsToProcess
+                    .GroupBy(l => l.Action)
+                    .ToDictionary(g => g.Key ?? "UNKNOWN", g => g.Count());
+
+                // Suppression effective
+                _context.AuditLogs.RemoveRange(logsToProcess);
+                await _context.SaveChangesAsync();
+
+                stopwatch.Stop();
+
+                _logger.LogInformation("✅ Nettoyage manuel terminé : {Count} logs supprimés en {Duration}ms",
+                                      logsToProcess.Count, stopwatch.ElapsedMilliseconds);
+
+                // Créer un log d'audit pour cette opération
+                var auditEntry = new AuditLog
+                {
+                    UserId = User.FindFirst(System.Security.Claims.ClaimTypes.NameIdentifier)?.Value ?? "ADMIN",
+                    Action = "MANUAL_AUDIT_CLEANUP",
+                    Message = $"Nettoyage manuel : {logsToProcess.Count} logs supprimés. Type: {request.ActionType ?? "TOUS"}, Rétention: {request.RetentionDays} jours",
+                    CreatedAt = DateTime.UtcNow,
+                    IpAddress = HttpContext.Connection.RemoteIpAddress?.ToString()
+                };
+
+                _context.AuditLogs.Add(auditEntry);
+                await _context.SaveChangesAsync();
+
+                return Ok(new CleanupResponse
+                {
+                    Message = $"Nettoyage terminé : {logsToProcess.Count} logs supprimés avec succès",
+                    DeletedCount = logsToProcess.Count,
+                    CutoffDate = cutoffDate,
+                    DetailedStats = detailedStats,
+                    ArchiveFilePath = archiveFilePath,
+                    DurationMs = stopwatch.ElapsedMilliseconds,
+                    IsPreview = false
+                });
+            }
+            catch (Exception ex)
+            {
+                _logger.LogError(ex, "Erreur lors du nettoyage manuel des logs");
+                return StatusCode(500, "Erreur lors du nettoyage des logs");
+            }
+        }
+
+        /// <summary>
+        /// Configuration des politiques de rétention
+        /// </summary>
+        [HttpGet("retention-config")]
+        public IActionResult GetRetentionConfig()
+        {
+            try
+            {
+                var config = new RetentionPolicyConfig();
+
+                // Chargement depuis la configuration
+                var configSection = _configuration.GetSection("AuditSettings");
+
+                if (configSection.Exists())
+                {
+                    config.AutoCleanupEnabled = configSection.GetValue<bool>("CleanupEnabled", true);
+                    config.CleanupIntervalHours = configSection.GetValue<int>("CleanupIntervalHours", 24);
+                    config.ArchiveBeforeDelete = configSection.GetValue<bool>("ArchiveBeforeDelete", false);
+                    config.ArchivePath = configSection.GetValue<string>("ArchivePath", "archives/audit") ?? "archives/audit";
+                    config.DefaultRetentionDays = configSection.GetValue<int>("DefaultRetentionDays", 180);
+
+                    // Politiques spécifiques
+                    var retentionSection = configSection.GetSection("RetentionPolicies");
+                    if (retentionSection.Exists())
+                    {
+                        foreach (var child in retentionSection.GetChildren())
+                        {
+                            if (int.TryParse(child.Value, out int days))
+                            {
+                                config.Policies[child.Key] = days;
+                            }
+                        }
+                    }
+                }
+
+                return Ok(config);
+            }
+            catch (Exception ex)
+            {
+                _logger.LogError(ex, "Erreur lors de la récupération de la configuration");
+                return StatusCode(500, "Erreur lors de la récupération de la configuration");
+            }
+        }
+
+        /// <summary>
+        /// Liste les fichiers d'archive
+        /// </summary>
+        [HttpGet("archives")]
+        public IActionResult ListArchives()
+        {
+            try
+            {
+                var archives = _archiveService.ListArchiveFiles();
+                return Ok(archives);
+            }
+            catch (Exception ex)
+            {
+                _logger.LogError(ex, "Erreur lors de la récupération des archives");
+                return StatusCode(500, "Erreur lors de la récupération des archives");
+            }
+        }
+
+        /// <summary>
+        /// Télécharge un fichier d'archive
+        /// </summary>
+        [HttpGet("archives/download/{fileName}")]
+        public IActionResult DownloadArchive(string fileName)
+        {
+            try
+            {
+                var archivePath = _configuration.GetValue<string>("AuditSettings:ArchivePath", "archives/audit") ?? "archives/audit";
+                var filePath = Path.Combine(archivePath, fileName);
+
+                if (!System.IO.File.Exists(filePath))
+                {
+                    return NotFound("Fichier d'archive non trouvé");
+                }
+
+                // Vérification de sécurité : le fichier doit être dans le dossier d'archives
+                var fullArchivePath = Path.GetFullPath(archivePath);
+                var fullFilePath = Path.GetFullPath(filePath);
+
+                if (!fullFilePath.StartsWith(fullArchivePath))
+                {
+                    _logger.LogWarning("⚠️ Tentative d'accès à un fichier hors du dossier d'archives : {FilePath}", fileName);
+                    return BadRequest("Chemin de fichier non autorisé");
+                }
+
+                var fileBytes = System.IO.File.ReadAllBytes(filePath);
+                var contentType = fileName.EndsWith(".json") ? "application/json" :
+                                fileName.EndsWith(".csv") ? "text/csv" :
+                                "application/octet-stream";
+
+                return File(fileBytes, contentType, fileName);
+            }
+            catch (Exception ex)
+            {
+                _logger.LogError(ex, "Erreur lors du téléchargement de l'archive {FileName}", fileName);
+                return StatusCode(500, "Erreur lors du téléchargement");
+            }
+        }
+
+        /// <summary>
+        /// Supprime les anciens fichiers d'archive
+        /// </summary>
+        [HttpDelete("archives/cleanup")]
+        public async Task<IActionResult> CleanupArchives([FromQuery] int maxAgeDays = 365)
+        {
+            try
+            {
+                if (maxAgeDays < 1)
+                {
+                    return BadRequest("L'âge maximum doit être d'au moins 1 jour");
+                }
+
+                var maxAge = TimeSpan.FromDays(maxAgeDays);
+                var deletedCount = await _archiveService.CleanupOldArchivesAsync(maxAge);
+
+                return Ok(new
+                {
+                    Message = $"Nettoyage des archives terminé",
+                    DeletedCount = deletedCount,
+                    MaxAgeDays = maxAgeDays
+                });
+            }
+            catch (Exception ex)
+            {
+                _logger.LogError(ex, "Erreur lors du nettoyage des archives");
+                return StatusCode(500, "Erreur lors du nettoyage des archives");
+            }
+        }
+
+        /// <summary>
+        /// Force le nettoyage automatique immédiatement
+        /// </summary>
+        [HttpPost("force-cleanup")]
+        public async Task<IActionResult> ForceAutoCleanup()
+        {
+            try
+            {
+                // Cette action déclenche manuellement le même processus que le BackgroundService
+                _logger.LogInformation("🔧 Nettoyage automatique forcé par un administrateur");
+
+                // Récupération des politiques de rétention
+                var retentionPolicies = GetRetentionPoliciesFromConfig();
+                int totalDeleted = 0;
+                var deletionStats = new Dictionary<string, int>();
+
+                foreach (var policy in retentionPolicies)
+                {
+                    var actionPattern = policy.Key;
+                    var retentionDays = policy.Value;
+                    var cutoffDate = DateTime.UtcNow.AddDays(-retentionDays);
+
+                    List<AuditLog> logsToDelete;
+
+                    if (actionPattern == "DEFAULT")
+                    {
+                        var knownActions = retentionPolicies.Keys.Where(k => k != "DEFAULT").ToList();
+                        logsToDelete = await _context.AuditLogs
+                            .Where(log => log.CreatedAt < cutoffDate &&
+                                         !knownActions.Any(action => log.Action.Contains(action)))
+                            .ToListAsync();
+                    }
+                    else
+                    {
+                        logsToDelete = await _context.AuditLogs
+                            .Where(log => log.Action.Contains(actionPattern) && log.CreatedAt < cutoffDate)
+                            .ToListAsync();
+                    }
+
+                    if (logsToDelete.Any())
+                    {
+                        _context.AuditLogs.RemoveRange(logsToDelete);
+                        deletionStats[actionPattern] = logsToDelete.Count;
+                        totalDeleted += logsToDelete.Count;
+                    }
+                }
+
+                if (totalDeleted > 0)
+                {
+                    await _context.SaveChangesAsync();
+
+                    // Log d'audit pour le nettoyage forcé
+                    var auditEntry = new AuditLog
+                    {
+                        UserId = User.FindFirst(System.Security.Claims.ClaimTypes.NameIdentifier)?.Value ?? "ADMIN",
+                        Action = "FORCED_AUTO_CLEANUP",
+                        Message = $"Nettoyage automatique forcé : {totalDeleted} logs supprimés",
+                        CreatedAt = DateTime.UtcNow,
+                        IpAddress = HttpContext.Connection.RemoteIpAddress?.ToString()
+                    };
+
+                    _context.AuditLogs.Add(auditEntry);
+                    await _context.SaveChangesAsync();
+                }
+
+                return Ok(new
+                {
+                    Message = $"Nettoyage automatique forcé terminé",
+                    DeletedCount = totalDeleted,
+                    DetailedStats = deletionStats
+                });
+            }
+            catch (Exception ex)
+            {
+                _logger.LogError(ex, "Erreur lors du nettoyage automatique forcé");
+                return StatusCode(500, "Erreur lors du nettoyage forcé");
+            }
+        }
+
+        /// <summary>
+        /// Récupère les politiques de rétention depuis la configuration
+        /// </summary>
+        private Dictionary<string, int> GetRetentionPoliciesFromConfig()
+        {
+            var policies = new Dictionary<string, int>();
+
+            var configSection = _configuration.GetSection("AuditSettings:RetentionPolicies");
+
+            if (configSection.Exists())
+            {
+                foreach (var child in configSection.GetChildren())
+                {
+                    if (int.TryParse(child.Value, out int days))
+                    {
+                        policies[child.Key] = days;
+                    }
+                }
+            }
+
+            // Politiques par défaut si configuration vide
+            if (!policies.Any())
+            {
+                policies = new Dictionary<string, int>
+                {
+                    { "LOGIN", 180 },
+                    { "LOGOUT", 90 },
+                    { "REGISTER", 365 },
+                    { "PROFILE_UPDATED", 365 },
+                    { "BOOK_CREATED", 730 },
+                    { "BOOK_DELETED", 730 },
+                    { "BOOK_DOWNLOADED", 90 },
+                    { "BOOK_VIEWED", 30 },
+                    { "FAVORITE_ADDED", 90 },
+                    { "FAVORITE_REMOVED", 90 },
+                    { "UNAUTHORIZED_ACCESS", 365 },
+                    { "RATE_LIMIT_EXCEEDED", 90 },
+                    { "SYSTEM_ERROR", 365 },
+                    { "DEFAULT", 180 }
+                };
+            }
+
+            return policies;
+        }
+
+        /// <summary>
+        /// Statistiques rapides pour le dashboard
+        /// </summary>
         [HttpGet("stats")]
-        public async Task<IActionResult> GetStats()
+        public async Task<IActionResult> GetQuickStats()
+        {
+            try
+            {
+                var stats = new
+                {
+                    TotalLogs = await _context.AuditLogs.CountAsync(),
+                    LogsToday = await _context.AuditLogs
+                        .CountAsync(a => a.CreatedAt >= DateTime.UtcNow.Date),
+                    LogsLast7Days = await _context.AuditLogs
+                        .CountAsync(a => a.CreatedAt >= DateTime.UtcNow.AddDays(-7)),
+                    LoginAttempts = await _context.AuditLogs
+                        .CountAsync(a => a.Action.Contains("LOGIN")),
+                    BookActions = await _context.AuditLogs
+                        .CountAsync(a => a.Action.Contains("BOOK")),
+                    SecurityEvents = await _context.AuditLogs
+                        .CountAsync(a => a.Action.Contains("UNAUTHORIZED") ||
+                                       a.Action.Contains("RATE_LIMIT") ||
+                                       a.Action.Contains("SYSTEM_ERROR"))
+                };
+
+                return Ok(stats);
+            }
+            catch (Exception ex)
+            {
+                _logger.LogError(ex, "Erreur lors de la récupération des statistiques rapides");
+                return StatusCode(500, "Erreur lors de la récupération des statistiques");
+            }
+        }
+
+        /// <summary>
+        /// Recherche dans les logs d'audit
+        /// </summary>
+        [HttpGet("search")]
+        public async Task<IActionResult> SearchLogs(
+            [FromQuery] string? query,
+            [FromQuery] string? action,
+            [FromQuery] string? userId,
+            [FromQuery] DateTime? startDate,
+            [FromQuery] DateTime? endDate,
+            [FromQuery] int page = 1,
+            [FromQuery] int size = 50)
+        {
+            try
+            {
+                if (page < 1 || size < 1 || size > 200)
+                {
+                    return BadRequest("Page doit être >= 1 et size entre 1 et 200");
+                }
+
+                var logsQuery = _context.AuditLogs.AsQueryable();
+
+                // Filtres
+                if (!string.IsNullOrEmpty(query))
+                {
+                    logsQuery = logsQuery.Where(l => l.Message.Contains(query) ||
+                                                   l.Action.Contains(query));
+                }
+
+                if (!string.IsNullOrEmpty(action))
+                {
+                    logsQuery = logsQuery.Where(l => l.Action.Contains(action));
+                }
+
+                if (!string.IsNullOrEmpty(userId))
+                {
+                    logsQuery = logsQuery.Where(l => l.UserId == userId);
+                }
+
+                if (startDate.HasValue)
+                {
+                    logsQuery = logsQuery.Where(l => l.CreatedAt >= startDate.Value);
+                }
+
+                if (endDate.HasValue)
+                {
+                    logsQuery = logsQuery.Where(l => l.CreatedAt <= endDate.Value);
+                }
+
+                var totalItems = await logsQuery.CountAsync();
+
+                var logs = await logsQuery
+                    .OrderByDescending(l => l.CreatedAt)
+                    .Skip((page - 1) * size)
+                    .Take(size)
+                    .Select(l => new
+                    {
+                        l.Id,
+                        l.UserId,
+                        l.Action,
+                        l.Message,
+                        l.CreatedAt,
+                        l.IpAddress
+                    })
+                    .ToListAsync();
+
+                return Ok(new
+                {
+                    Logs = logs,
+                    Pagination = new
+                    {
+                        Page = page,
+                        Size = size,
+                        TotalItems = totalItems,
+                        TotalPages = (int)Math.Ceiling(totalItems / (double)size)
+                    },
+                    Filters = new
+                    {
+                        Query = query,
+                        Action = action,
+                        UserId = userId,
+                        StartDate = startDate,
+                        EndDate = endDate
+                    }
+                });
+            }
+            catch (Exception ex)
+            {
+                _logger.LogError(ex, "Erreur lors de la recherche dans les logs");
+                return StatusCode(500, "Erreur lors de la recherche");
+            }
+        }
+
+        /// <summary>
+        /// Export personnalisé des logs d'audit
+        /// </summary>
+        [HttpPost("export")]
+        public async Task<IActionResult> ExportLogs([FromBody] ExportRequest request)
         {
-            var today = DateTime.UtcNow.Date;
-            var stats = new
+            try
             {
-                TotalLogs = await _context.AuditLogs.CountAsync(),
-                TodayLogs = await _context.AuditLogs.CountAsync(a => a.CreatedAt >= today),
-                LoginAttempts = await _context.AuditLogs.CountAsync(a => a.Action.Contains("LOGIN")),
-                BookActions = await _context.AuditLogs.CountAsync(a => a.Action.Contains("BOOK"))
-            };
+                var logsQuery = _context.AuditLogs.AsQueryable();
+
+                // Application des filtres
+                if (request.StartDate.HasValue)
+                {
+                    logsQuery = logsQuery.Where(l => l.CreatedAt >= request.StartDate.Value);
+                }
+
+                if (request.EndDate.HasValue)
+                {
+                    logsQuery = logsQuery.Where(l => l.CreatedAt <= request.EndDate.Value);
+                }
+
+                if (!string.IsNullOrEmpty(request.ActionType))
+                {
+                    logsQuery = logsQuery.Where(l => l.Action.Contains(request.ActionType));
+                }
+
+                if (!string.IsNullOrEmpty(request.UserId))
+                {
+                    logsQuery = logsQuery.Where(l => l.UserId == request.UserId);
+                }
+
+                var logs = await logsQuery
+                    .OrderBy(l => l.CreatedAt)
+                    .Take(Math.Min(request.MaxRecords, 10000)) // Limite de sécurité
+                    .ToListAsync();
 
-            return Ok(stats);
+                if (!logs.Any())
+                {
+                    return BadRequest("Aucun log trouvé selon les critères spécifiés");
+                }
+
+                // Export via le service d'archivage
+                var archiveFormat = request.Format.ToUpperInvariant() == "JSON"
+                    ? ArchiveFormat.JSON
+                    : ArchiveFormat.CSV;
+
+                var actionType = request.ActionType ?? "CUSTOM_EXPORT";
+                var filePath = await _archiveService.ArchiveLogsAsync(
+                    logs, actionType, archiveFormat, request.Compress);
+
+                var fileBytes = await System.IO.File.ReadAllBytesAsync(filePath);
+                var fileName = Path.GetFileName(filePath);
+                var contentType = archiveFormat == ArchiveFormat.JSON ? "application/json" : "text/csv";
+
+                if (request.Compress)
+                {
+                    contentType = "application/gzip";
+                }
+
+                // Log de l'export
+                var auditEntry = new AuditLog
+                {
+                    UserId = User.FindFirst(System.Security.Claims.ClaimTypes.NameIdentifier)?.Value ?? "ADMIN",
+                    Action = "AUDIT_EXPORT",
+                    Message = $"Export de {logs.Count} logs au format {request.Format}",
+                    CreatedAt = DateTime.UtcNow,
+                    IpAddress = HttpContext.Connection.RemoteIpAddress?.ToString()
+                };
+
+                _context.AuditLogs.Add(auditEntry);
+                await _context.SaveChangesAsync();
+
+                return File(fileBytes, contentType, fileName);
+            }
+            catch (Exception ex)
+            {
+                _logger.LogError(ex, "Erreur lors de l'export des logs");
+                return StatusCode(500, "Erreur lors de l'export");
+            }
         }
     }
+
+    /// <summary>
+    /// Modèle pour les requêtes d'export personnalisé
+    /// </summary>
+    public class ExportRequest
+    {
+        public DateTime? StartDate { get; set; }
+        public DateTime? EndDate { get; set; }
+        public string? ActionType { get; set; }
+        public string? UserId { get; set; }
+        public string Format { get; set; } = "CSV"; // CSV ou JSON
+        public bool Compress { get; set; } = false;
+        public int MaxRecords { get; set; } = 5000;
+    }
 }
 
+/*
+================================================================================
+                           DOCUMENTATION - AuditController
+================================================================================
+
+DESCRIPTION GÉNÉRALE :
+Le AuditController est un contrôleur d'administration destiné à la gestion 
+complète des logs d'audit dans l'API Library. Il fournit des fonctionnalités 
+avancées de consultation, analyse, nettoyage et archivage des données d'audit.
+
+SÉCURITÉ :
+- Accès restreint aux utilisateurs avec le rôle "Admin" uniquement
+- Validation des paramètres d'entrée pour éviter les injections
+- Vérification des chemins de fichiers pour empêcher le directory traversal
+- Logging de toutes les opérations sensibles
+
+================================================================================
+                                 ENDPOINTS
+================================================================================
+
+📊 CONSULTATION ET STATISTIQUES
+-------------------------------
+
+GET /api/admin/audit/logs
+- Récupère les logs d'audit avec pagination
+- Paramètres : page (défaut: 1), size (défaut: 50, max: 200)
+- Retourne : liste paginée des logs avec métadonnées de pagination
+
+GET /api/admin/audit/database-size
+- Fournit des statistiques détaillées sur la base de données d'audit
+- Inclut : nombre total, distribution temporelle, top actions, estimations de taille
+- Performance : optimisé avec des requêtes groupées et calculs en parallèle
+
+GET /api/admin/audit/stats
+- Statistiques rapides pour tableau de bord
+- Métriques : logs totaux, aujourd'hui, 7 derniers jours, par catégories
+- Usage : idéal pour des widgets de monitoring
+
+🔍 RECHERCHE ET FILTRAGE
+------------------------
+
+GET /api/admin/audit/search
+- Recherche avancée dans les logs avec filtres multiples
+- Filtres : query (texte libre), action, userId, startDate, endDate
+- Pagination : support complet avec métadonnées
+- Performance : indexation recommandée sur CreatedAt et Action
+
+🧹 NETTOYAGE ET MAINTENANCE
+---------------------------
+
+POST /api/admin/audit/cleanup
+- Nettoyage manuel des logs avec options avancées
+- Body : CleanupRequest (retentionDays, actionType?, previewOnly?, archiveBeforeDelete?)
+- Fonctionnalités :
+  * Mode preview pour estimation avant suppression
+  * Archivage automatique optionnel
+  * Statistiques détaillées par type d'action
+  * Logging de l'opération dans l'audit trail
+
+POST /api/admin/audit/force-cleanup
+- Déclenche immédiatement le processus de nettoyage automatique
+- Utilise les politiques de rétention configurées
+- Idéal pour maintenance planifiée ou résolution d'urgence
 
-/* pour tester :
+⚙️ CONFIGURATION
+----------------
 
-### Connexion (génère un log)
-POST https://localhost:5001/api/Auth/login
-Content-Type: application/json
+GET /api/admin/audit/retention-config
+- Récupère la configuration des politiques de rétention
+- Sources : appsettings.json section "AuditSettings"
+- Inclut : intervalles de nettoyage, politiques par action, chemins d'archivage
 
+📁 GESTION DES ARCHIVES
+-----------------------
+
+GET /api/admin/audit/archives
+- Liste tous les fichiers d'archive disponibles
+- Informations : nom, taille, date de création, format
+
+GET /api/admin/audit/archives/download/{fileName}
+- Télécharge un fichier d'archive spécifique
+- Sécurité : validation du chemin pour éviter directory traversal
+- Formats supportés : JSON, CSV, avec compression optionnelle
+
+DELETE /api/admin/audit/archives/cleanup
+- Supprime les archives anciennes selon l'âge spécifié
+- Paramètre : maxAgeDays (défaut: 365)
+- Retourne : nombre de fichiers supprimés
+
+📤 EXPORT PERSONNALISÉ
+----------------------
+
+POST /api/admin/audit/export
+- Export personnalisé avec filtres avancés
+- Body : ExportRequest (dates, actionType, userId, format, compress, maxRecords)
+- Formats : CSV, JSON
+- Limite : 10 000 enregistrements maximum par export
+- Compression : support gzip optionnel
+
+================================================================================
+                            MODÈLES DE DONNÉES
+================================================================================
+
+ExportRequest
+- StartDate/EndDate : plage temporelle
+- ActionType : filtre par type d'action
+- UserId : filtre par utilisateur
+- Format : "CSV" ou "JSON"
+- Compress : bool pour compression gzip
+- MaxRecords : limite (max 10 000)
+
+CleanupRequest
+- RetentionDays : nombre de jours à conserver
+- ActionType : type d'action spécifique (optionnel)
+- PreviewOnly : mode aperçu sans suppression
+- ArchiveBeforeDelete : archivage automatique avant suppression
+
+AuditDatabaseStats
+- TotalLogs : nombre total de logs
+- LogsLast7Days/Last30Days : métriques temporelles
+- OldestLog/NewestLog : dates extrêmes
+- TopActions : liste des actions les plus fréquentes
+- MonthlyDistribution : répartition mensuelle
+- SizeEstimate : estimation de l'espace disque
+
+================================================================================
+                           CONFIGURATION RECOMMANDÉE
+================================================================================
+
+appsettings.json :
 {
-  "email": "admin@library.com",
-  "password": "AdminPass123!"
+  "AuditSettings": {
+    "CleanupEnabled": true,
+    "CleanupIntervalHours": 24,
+    "ArchiveBeforeDelete": false,
+    "ArchivePath": "archives/audit",
+    "DefaultRetentionDays": 180,
+    "RetentionPolicies": {
+      "LOGIN": 180,
+      "LOGOUT": 90,
+      "REGISTER": 365,
+      "BOOK_CREATED": 730,
+      "BOOK_DELETED": 730,
+      "BOOK_DOWNLOADED": 90,
+      "UNAUTHORIZED_ACCESS": 365,
+      "SYSTEM_ERROR": 365,
+      "DEFAULT": 180
+    }
+  }
 }
 
-### Consulter les logs (Admin)
-GET https://localhost:5001/api/admin/audit/logs?page=1&size=10
-Authorization: Bearer YOUR_ADMIN_TOKEN
+================================================================================
+                              DÉPENDANCES
+================================================================================
+
+Services injectés :
+- ApplicationDbContext : accès aux données
+- ILogger<AuditController> : logging des opérations
+- AuditArchiveService : gestion des archives
+- IConfiguration : lecture de la configuration
+
+Services externes requis :
+- Entity Framework Core pour les requêtes LINQ
+- System.Diagnostics pour la mesure de performances
+- System.IO pour la gestion des fichiers
+
+================================================================================
+                         CONSIDÉRATIONS DE PERFORMANCE
+================================================================================
+
+OPTIMISATIONS IMPLÉMENTÉES :
+- Requêtes LINQ avec Select() pour limiter les données transférées
+- Pagination systématique avec Skip/Take
+- Utilisation d'index sur CreatedAt recommandée
+- Calculs statistiques optimisés avec GroupBy
+- Stopwatch pour mesurer les temps d'exécution
+
+RECOMMANDATIONS :
+- Index base de données sur (CreatedAt, Action)
+- Planification du nettoyage automatique hors heures de pointe
+- Monitoring de la taille de la base de données
+- Archivage régulier pour maintenir les performances
+
+================================================================================
+                            SÉCURITÉ ET AUDIT
+================================================================================
+
+MESURES DE SÉCURITÉ :
+- Autorisation admin obligatoire sur tous les endpoints
+- Validation des paramètres d'entrée
+- Limitation du nombre d'enregistrements exportables
+- Vérification des chemins de fichiers
+- Logging de toutes les opérations sensibles
+
+AUDIT TRAIL :
+- Toutes les opérations de nettoyage sont loggées
+- Les exports sont tracés avec détails
+- Les accès aux archives sont enregistrés
+- Horodatage UTC pour toutes les opérations
+
+================================================================================
+                              MAINTENANCE
+================================================================================
+
+TÂCHES RÉGULIÈRES :
+- Surveillance de la croissance des logs
+- Vérification des archives générées
+- Contrôle des politiques de rétention
+- Monitoring des performances du nettoyage
+
+DÉPANNAGE :
+- Vérifier les logs d'erreur pour les échecs de nettoyage
+- Contrôler l'espace disque pour les archives
+- Valider la configuration des politiques de rétention
+- Surveiller les temps de réponse des requêtes statistiques
+
+================================================================================
+                                CHANGELOG
+================================================================================
+
+Version actuelle : Fonctionnalités complètes
+- Gestion complète des logs d'audit
+- Système d'archivage intégré
+- Politiques de rétention configurables
+- Export personnalisé multi-format
+- Statistiques avancées avec distribution temporelle
+- Interface de nettoyage manuel et automatique
+
+Améliorations futures potentielles :
+- Interface graphique pour la visualisation des statistiques
+- Alertes automatiques en cas de croissance anormale
+- API de streaming pour très gros exports
+- Compression différentielle des archives
+- Intégration avec systèmes de monitoring externes
 
-### Statistiques
-GET https://localhost:5001/api/admin/audit/stats
-Authorization: Bearer YOUR_ADMIN_TOKEN
-*/
\ No newline at end of file
+================================================================================
+*/
diff --git a/src/Program.cs b/src/Program.cs
index 09f9caf..bf8bd09 100644
--- a/src/Program.cs
+++ b/src/Program.cs
@@ -16,6 +16,8 @@ using Microsoft.OpenApi.Models;
 using LibraryAPI.Models;
 using LibraryAPI.Data;
 
+using LibraryAPI.Services; // utilisé pour services de nettoyage et d'archivage automatique en arrière-plan
+
 // ✅ IMPORTS POUR LA VALIDATION RENFORCÉE
 // Importation des filtres de validation personnalisés
 using LibraryAPI.Filters;
@@ -303,6 +305,12 @@ builder.Services.AddScoped<EmailService>();
 builder.Services.AddHttpContextAccessor(); // pas sûr que ce soit utile ici ...
 builder.Services.AddScoped<AuditLogger>();
 
+// Ajout du service d'archivage automatique en arrière-plan
+builder.Services.AddScoped<AuditArchiveService>();
+
+// Ajout du service de nettoyage automatique en arrière-plan
+builder.Services.AddHostedService<AuditCleanupService>();
+
 // Configuration des politiques de limitation de taux pour protéger l'API contre les abus
 // Le rate limiting permet de contrôler le nombre de requêtes par utilisateur/IP dans un intervalle de temps donné
 builder.Services.AddRateLimiter(options =>
diff --git a/src/appsettings.Development.json b/src/appsettings.Development.json
index 2be8e23..5c4add6 100644
--- a/src/appsettings.Development.json
+++ b/src/appsettings.Development.json
@@ -1,3 +1,80 @@
 {
-  "EnableSwagger": true
+  "EnableSwagger": true,
+
+  "_comment_AuditSettings": "Configuration complète pour la gestion des logs d'audit et leur rétention",
+  "AuditSettings": {
+    "_comment_RetentionPolicies": "Durées de rétention en jours par type d'action",
+    "RetentionPolicies": {
+      "_comment_Auth": "Actions d'authentification - 6 mois pour détecter les intrusions",
+      "LOGIN_SUCCESS": 180,
+      "LOGIN_FAILED": 180,
+      "LOGOUT": 90,
+      "REGISTER": 365,
+
+      "_comment_Profile": "Modifications de profil - 1 an pour traçabilité utilisateur",
+      "PROFILE_UPDATED": 365,
+      "PASSWORD_CHANGED": 365,
+
+      "_comment_Books": "Actions sur les livres - 2 ans pour audit métier critique",
+      "BOOK_CREATED": 730,
+      "BOOK_UPDATED": 730,
+      "BOOK_DELETED": 730,
+      "BOOK_RATED": 365,
+      "BOOK_COMMENTED": 365,
+
+      "_comment_Usage": "Utilisation normale - durées courtes car très volumineux",
+      "BOOK_DOWNLOADED": 90,
+      "BOOK_VIEWED": 30,
+
+      "_comment_Favorites": "Gestion des favoris - 3 mois",
+      "FAVORITE_ADDED": 90,
+      "FAVORITE_REMOVED": 90,
+
+      "_comment_Security": "Événements de sécurité - 1 an pour conformité",
+      "UNAUTHORIZED_ACCESS": 365,
+      "RATE_LIMIT_EXCEEDED": 90,
+      "SUSPICIOUS_ACTIVITY": 365,
+      "TOKEN_EXPIRED": 90,
+
+      "_comment_System": "Événements système",
+      "SYSTEM_ERROR": 365,
+      "SYSTEM_STARTUP": 90,
+      "SYSTEM_SHUTDOWN": 90,
+
+      "_comment_Admin": "Actions administrateur - 2 ans minimum",
+      "USER_ROLE_CHANGED": 730,
+      "USER_DELETED": 730,
+      "NOTIFICATION_SENT": 180,
+      "AUDIT_CLEANUP": 730,
+      "MANUAL_AUDIT_CLEANUP": 730,
+      "FORCED_AUTO_CLEANUP": 730,
+
+      "_comment_Default": "Politique par défaut pour les actions non spécifiées - 6 mois",
+      "DEFAULT": 180
+    },
+
+    "_comment_AutoCleanup": "Configuration du nettoyage automatique",
+    "CleanupEnabled": true,
+    "CleanupIntervalHours": 24,
+
+    "_comment_Archive": "Configuration de l'archivage avant suppression",
+    "ArchiveBeforeDelete": false,
+    "ArchivePath": "archives/audit",
+    "ArchiveFormat": "JSON",
+    "CompressArchives": false,
+
+    "_comment_Performance": "Paramètres de performance",
+    "BatchSize": 1000,
+    "MaxConcurrentCleanupTasks": 3,
+
+    "_comment_Monitoring": "Surveillance et alertes",
+    "AlertOnLargeCleanup": true,
+    "LargeCleanupThreshold": 10000,
+    "LogCleanupStatistics": true,
+
+    "_comment_Backup": "Gestion des archives",
+    "ArchiveRetentionDays": 1095,
+    "AutoCleanupArchives": true,
+    "MaxArchiveSizeMB": 100
+  }
 }
diff --git a/src/appsettings.Production.json b/src/appsettings.Production.json
index 2be8e23..5c4add6 100644
--- a/src/appsettings.Production.json
+++ b/src/appsettings.Production.json
@@ -1,3 +1,80 @@
 {
-  "EnableSwagger": true
+  "EnableSwagger": true,
+
+  "_comment_AuditSettings": "Configuration complète pour la gestion des logs d'audit et leur rétention",
+  "AuditSettings": {
+    "_comment_RetentionPolicies": "Durées de rétention en jours par type d'action",
+    "RetentionPolicies": {
+      "_comment_Auth": "Actions d'authentification - 6 mois pour détecter les intrusions",
+      "LOGIN_SUCCESS": 180,
+      "LOGIN_FAILED": 180,
+      "LOGOUT": 90,
+      "REGISTER": 365,
+
+      "_comment_Profile": "Modifications de profil - 1 an pour traçabilité utilisateur",
+      "PROFILE_UPDATED": 365,
+      "PASSWORD_CHANGED": 365,
+
+      "_comment_Books": "Actions sur les livres - 2 ans pour audit métier critique",
+      "BOOK_CREATED": 730,
+      "BOOK_UPDATED": 730,
+      "BOOK_DELETED": 730,
+      "BOOK_RATED": 365,
+      "BOOK_COMMENTED": 365,
+
+      "_comment_Usage": "Utilisation normale - durées courtes car très volumineux",
+      "BOOK_DOWNLOADED": 90,
+      "BOOK_VIEWED": 30,
+
+      "_comment_Favorites": "Gestion des favoris - 3 mois",
+      "FAVORITE_ADDED": 90,
+      "FAVORITE_REMOVED": 90,
+
+      "_comment_Security": "Événements de sécurité - 1 an pour conformité",
+      "UNAUTHORIZED_ACCESS": 365,
+      "RATE_LIMIT_EXCEEDED": 90,
+      "SUSPICIOUS_ACTIVITY": 365,
+      "TOKEN_EXPIRED": 90,
+
+      "_comment_System": "Événements système",
+      "SYSTEM_ERROR": 365,
+      "SYSTEM_STARTUP": 90,
+      "SYSTEM_SHUTDOWN": 90,
+
+      "_comment_Admin": "Actions administrateur - 2 ans minimum",
+      "USER_ROLE_CHANGED": 730,
+      "USER_DELETED": 730,
+      "NOTIFICATION_SENT": 180,
+      "AUDIT_CLEANUP": 730,
+      "MANUAL_AUDIT_CLEANUP": 730,
+      "FORCED_AUTO_CLEANUP": 730,
+
+      "_comment_Default": "Politique par défaut pour les actions non spécifiées - 6 mois",
+      "DEFAULT": 180
+    },
+
+    "_comment_AutoCleanup": "Configuration du nettoyage automatique",
+    "CleanupEnabled": true,
+    "CleanupIntervalHours": 24,
+
+    "_comment_Archive": "Configuration de l'archivage avant suppression",
+    "ArchiveBeforeDelete": false,
+    "ArchivePath": "archives/audit",
+    "ArchiveFormat": "JSON",
+    "CompressArchives": false,
+
+    "_comment_Performance": "Paramètres de performance",
+    "BatchSize": 1000,
+    "MaxConcurrentCleanupTasks": 3,
+
+    "_comment_Monitoring": "Surveillance et alertes",
+    "AlertOnLargeCleanup": true,
+    "LargeCleanupThreshold": 10000,
+    "LogCleanupStatistics": true,
+
+    "_comment_Backup": "Gestion des archives",
+    "ArchiveRetentionDays": 1095,
+    "AutoCleanupArchives": true,
+    "MaxArchiveSizeMB": 100
+  }
 }
